---
title: "Export to '.tmat.hdf5' format with Julia"
author: "baptiste"
date: today
---

This document describes the process of exporting T-matrices in the standardised HDF5 format in Julia. For illustration, we start by producing a dummy dataset. A minimal reproducible example file is available for download: [test_dummy.jl](test_dummy.jl).

## Mockup input data

For convenience, we store compound objects as named tuples, which will then be mapped into HDF5 groups during export. I did not find how to link the embedding medium from materials to the top level, so it is simply duplicated.

```{.julia}
using Pkg, UUIDs

# possibly multiple wavelengths
wavelength = collect(400:50:800)
Nl = length(wavelength)

# dummy 30x30 matrix values for each wavelength
tmatrix = reshape(repeat(collect(1:900.0) + collect(1:900) * 1im, Nl),
    (30, 30, Nl))

modes = (l=collect(1:30),
    m=collect(1:30),
    polarisation=repeat(["electric", "magnetic"], 15))

# dummy 'analytical zeros' for e.g. EBCM methods
azeros = collect(Iterators.product(1:2:30, 1:2:30))
analytical_zeros = (q=[z[1] for z in azeros[:]],
    qp=[z[2] for z in azeros[:]])

embedding = (relative_permeability=1.0,
    relative_permittivity=1.33^2)

materials = (embedding=embedding,
    Au=(relative_permeability=1.0,
        relative_permittivity=repeat([-11.4 + 1.181im], Nl)))
        
geometry = (shape="spheroid",
    radiusxy=20.0,
    radiusz=40.0)

# details about computation, including full script
computation = (method="EBCM",
    software="SMARTIES",
    version="1.1",
    Ntheta=40,
    accuracy=1e-10,
    analytical_zeros=analytical_zeros,
    script=read("test_dummy.jl", String))


pkgs = Pkg.Operations.Context().env.manifest
hdf5version = string(pkgs[findfirst(v -> v.name == "HDF5", pkgs)].version)

all = (vacuum_wavelength=wavelength,
    tmatrix=tmatrix,
    modes=modes,
    embedding=embedding,
    materials=materials,
    geometry=geometry,
    computation=computation,
    uuid=string(UUIDs.uuid4()))
```


## Saving to HDF5

The `HDF5.jl` library provides all the tools required, and a relatively high-level interface. Unlike R and Matlab, there does not seem to be a built-in high-level way to store list-like objects (named tuples here), so I wrote the following wrapper (defined in file [_fun.jl](_fun.jl)).

```{.julia}
function write_namedtuples_to_hdf5_groups(
    parent::Union{HDF5.File,HDF5.Group},
    tuple::NamedTuple
)
```

Complex arrays are stored with `r` and `i` fields as usual. Note that Julia has column-major ordering, unlike HDF5, and we should therefore explicitly transpose the matrix before saving it, to avoid confusion if the data are to be read in another language.

```{.julia}

using HDF5

# custom write_dicts_to_hdf5_groups()
include("_fun.jl")

h5open("aj.tmat.h5", "w") do fid

    # write all data in groups
    write_namedtuples_to_hdf5_groups(fid, all)

    # write custom attributes
    attributes(fid)["name"] = "Au prolate spheroid in water"
    attributes(fid)["created_with"] = "HDF5.jl"
    attributes(fid)["storage_format_version"] = hdf5version
    attributes(fid)["description"] = "Computation using SMARTIES, a numerically robust EBCM implementation for spheroids"
    attributes(fid)["keywords"] = "gold, spheroid, ebcm"
    attributes(fid["vacuum_wavelength"])["unit"] = "nm"
    attributes(fid["uuid"])["version"] = "4"
    attributes(fid["geometry"])["name"] = "prolate spheroid"

end
```
