[
  {
    "objectID": "display.html",
    "href": "display.html",
    "title": "Displaying T-matrices with R",
    "section": "",
    "text": "R utility functions used below.\nThe following R code produces a visual heatmap of a T-matrix with a standard 2x2 block matrix layout and indexing conventions.\nExample data in long format:\n\nd &lt;- read.table('data/tmat_Au20x40_Nmax3.tmat')\nnames(d) &lt;- c('s','sp','l','lp','m','mp','Tr','Ti')\nd &lt;- tmatrix_combinedindex(d)\n\nCustom visualisation:\n\nlmax &lt;- max(d$l)\nbreaks &lt;- tmatrix_breaks(lmax)\n\np &lt;- ggplot(d, aes(q, qp, fill= log10(Mod(Tr + 1i*Ti)))) +\n  geom_raster() +\n  coord_equal() +\n  scale_fill_viridis_c(option = 'A', direction = -1) +\n  annotate('segment',x=0.5,xend=max(breaks$breaks)+0.5,y=max(breaks$breaks)/2+0.5,\n           yend=max(breaks$breaks)/2+0.5,colour='white')+\n  annotate('segment',y=0.5,yend=max(breaks$breaks)+0.5,x=max(breaks$breaks)/2+0.5,\n           xend=max(breaks$breaks)/2+0.5,colour='white')+\n  scale_y_reverse(expand=c(0,0), breaks= breaks$breaks+0.5, minor_breaks=breaks$minor_breaks+0.5, labels=breaks$labels) +\n  scale_x_continuous(expand=c(0,0), breaks= breaks$breaks+0.5, minor_breaks=breaks$minor_breaks+0.5, labels=breaks$labels) +\n  theme_minimal() +\n  theme(panel.grid = element_line(colour = 'white'), \n        panel.background = element_rect(fill='grey90',colour='white'),\n        panel.border = element_rect(colour='black',fill=NA,linewidth = 0.2),\n        axis.text.x = element_text(hjust=1),\n        axis.text.y = element_text(vjust=0)) +\n  labs(x=\"p\",y=\"p'\",fill=expression(log~\"|T|\"))\n\nprint(p)\n\n\n\n\n\n\n\n\nNote that ggplot2 makes it easy to plot multiple facets to compare different datasets,\n\n# combine data with another T-matrix from Treams\nd2 &lt;- read_treams('data/SPH-DE~4.H5')\nm &lt;- rbind(mutate(d, type = \"SMARTIES\"),\n           mutate(d2[,names(d)], type = \"Treams\"))\n\n# update the plot with these data, and facet by type\np %+% m + facet_wrap(~type)"
  },
  {
    "objectID": "indexing.html",
    "href": "indexing.html",
    "title": "Indexing conventions",
    "section": "",
    "text": "The convention is to use\n\nm: multipole order, -l:l\nl: multipole degree 1:lmax\ns: multipole polarisation type, 1 or 2\n\nso for a T-matrix with \\(lmax=3\\), we have\n\n\nl: 1..3\nm: -3..3\ns: 1..2\n900 elements\n\n\n\n\n\n\n\n\n\nfor each block we introduce a combined p-index such that,\n\\[\np(n,m) = n(n+1)+m\n\\] which here varies as p: 1..15, as each block is of dimension pmax = lmax(lmax+1)+lmax = 3(3+1)+3 = 15.\nThe whole T-matrix is indexed with a combined q-index such that,\n\\[\nq(s,p) = (s-1)p_{max} + p\n\\] which here gives us, q: 1..30. The total T-matrix dimension (along rows/columns) is thus \\(q_{max}=2\\times(lmax(lmax+1)+lmax)=30\\).\nIn summary, for a given \\(l_\\text{max}\\) the indices are given by:\n\n\\(l=1:l_\\text{max}\\)\n\\(m=-l:l\\) for each l\n\\(s=1:2\\) for each pair of (l,m)\n\\(p(l,m) = l(l+1)+m\\)\n\\(q(s,p) = (s-1)p_{max} + p\\)\n\nGiven \\(q\\) and \\(l_\\text{max}\\) we can invert these indices as follows,\n\n\\(p = q - (s-1)q_\\text{max}/2\\),\ngiving here, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15\n\\(l = \\lfloor\\sqrt{p}\\rfloor\\),\ngiving here 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3\n\\(m = p - l(l+1)\\),\ngiving here -1, 0, 1, -2, -1, 0, 1, 2, -3, -2, -1, 0, 1, 2, 3, -1, 0, 1, -2, -1, 0, 1, 2, -3, -2, -1, 0, 1, 2, 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n\np\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nl\n1\n1\n1\n2\n2\n2\n2\n2\n3\n3\n3\n3\n3\n3\n3\n1\n1\n1\n2\n2\n2\n2\n2\n3\n3\n3\n3\n3\n3\n3\n\n\nm\n-1\n0\n1\n-2\n-1\n0\n1\n2\n-3\n-2\n-1\n0\n1\n2\n3\n-1\n0\n1\n-2\n-1\n0\n1\n2\n-3\n-2\n-1\n0\n1\n2\n3\n\n\ns\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "R_export.html",
    "href": "R_export.html",
    "title": "Export to ‘.tmat.hdf5’ format with R",
    "section": "",
    "text": "This document describes a few R utility functions to export T-matrices in the standardised HDF5 format. For illustration, we start by producing a dummy dataset."
  },
  {
    "objectID": "R_export.html#mockup-input-data",
    "href": "R_export.html#mockup-input-data",
    "title": "Export to ‘.tmat.hdf5’ format with R",
    "section": "Mockup input data",
    "text": "Mockup input data\nThe rhdf5 package has support for a variety of R objects, including lists which are automatically written as grouped objects in HDF5.\n# possibly multiple wavelengths\nwavelength &lt;- seq(400, 800, by=50)\nNl &lt;- length(wavelength)\n\n# dummy 30x30 matrix values for each wavelength\ntmatrix &lt;- array(1:900 + 1i*(1:900), c(30,30,Nl))\n\nmodes &lt;- list('l' = 1:30,'m' = 1:30,\n              'polarization' =  rep(c('electric','magnetic'),15))\n\n# dummy 'analytical zeros' for e.g. EBCM methods\nzeros &lt;- expand.grid(p=seq(1,30,by=2), pp = seq(1,30,by=2))\n\nmaterials &lt;- list('embedding' = list('relative_permeability' = 1.0,\n                                     'relative_permittivity' = 1.33^2), \n                  'Au' = list('relative_permeability' = 1.0,\n                              'relative_permittivity' = -11.4+1.181i))\n\ngeometry &lt;- list('shape' = 'spheroid','radiusxy' = 20.0, 'radiusz' = 40.0)\n\n# details about computation, including full script\nscript &lt;-  glue::glue_collapse(readLines('test-dummy.R'), sep = \"\\n\")\ncomputation &lt;- list('method' ='EBCM',\n                    'software' = 'SMARTIES',\n                    'version' = '1.1',\n                    'Ntheta' = 40, \n                    'accuracy' = 1e-10, \n                    'analytical_zeros' = zeros,\n                    'script' = script)\n\nuuid &lt;- uuid::UUIDgenerate()\nhdf5version &lt;- glue::glue_collapse(H5get_libversion(),\".\")"
  },
  {
    "objectID": "R_export.html#saving-to-hdf5",
    "href": "R_export.html#saving-to-hdf5",
    "title": "Export to ‘.tmat.hdf5’ format with R",
    "section": "Saving to HDF5",
    "text": "Saving to HDF5\nThe rhdf5 package provides support for reading/writing HDF5 files into/from R objects. Until my recent request, complex arrays were not supported, but this is now implemented in the dev version of the package. The glue and purrr packages are only used for convenience, and can easily be replaced with base functions.\nlibrary(rhdf5) # note: requires dev version to support complex arrays\n# cf https://support.bioconductor.org/p/9156305/#9156408\n# install.packages(\"remotes\")\n# remotes::install_github(\"grimbough/rhdf5@devel\")\n# may need 'crypto' library from openSSL to compile\n# e.g. via brew install openssl on macos\n\nlibrary(uuid) # uuid\nlibrary(glue) # string interpolation\nlibrary(purrr) # mapping functions\n## create file\nf &lt;- 'ar.tmat.h5'\nunlink(f)\nh5createFile(f)\nh5closeAll()\nWe can then write the different objects defined above using hwrite. Note the important native = TRUE parameter for the T-matrix data: R stores arrays column-wise, while HDF5 uses row-major ordering. To avoid confusion between different programming languages, we suggest sticking with the native HDF5 convention (native = TRUE ensures that the array is written transposed).\n## write file\nh5write(tmatrix, file=f, name=\"/tmatrix\", native=TRUE) # store rowwise\n# Using native = TRUE increases HDF5 file portability between programming languages\nh5write(modes, file=f, name='/modes')\nh5write(wavelength, file=f, name=\"/vacuum_wavelength\")\nh5write(embedding, file=f, name=\"/embedding\")\nh5write(materials, file=f, name=\"/materials\")\nh5write(geometry, file=f, name=\"/geometry\")\nh5write(computation, file=f, name='/computation')\nh5write(uuid, file=f, name='/uuid')\nAttributes are written in a separate step, and a convenience wrapper function write_attributes(object, names, attributes, type) is used to simplify the interface.\n## open file\nfid &lt;- H5Fopen(f)\n## root attributes\nwrite_attributes(\"/\",\n                 names = list(\"name\",\n                              \"created_with\",\n                              \"storage_format_version\",\n                              \"description\", \n                              'keywords'), \n                 attributes = list(\"Au prolate spheroid in water\",\n                                   \"rhdf5\",\n                                   hdf5version,\n                    \"Computation using SMARTIES, a robust EBCM for spheroids\", 'gold, spheroid, ebcm'), \n                 type = \"root\")\n\n## object attributes\nwrite_attributes(\"tmatrix\",\n                 names=c(\"units\",\"created_with\"),\n                 attributes = c(\"nm\",\"rhdf5\"), \n                 type = \"dataset\")\n\nwrite_attributes(\"vacuum_wavelength\",\n                 names=c(\"unit\"), \n                 attributes = c(\"nm\"), \n                 type = \"dataset\")\n\nwrite_attributes(\"uuid\",\n                 names=c(\"version\"), \n                 attributes = c(\"4\"), \n                 type = \"dataset\")\n\nwrite_attributes(\"geometry\",\n                 names=c(\"name\"), \n                 attributes = c(\"prolate spheroid\"), \n                 type = \"group\")\n## close file\nH5Fclose(fid)"
  },
  {
    "objectID": "conversion.html",
    "href": "conversion.html",
    "title": "Conversion long/wide",
    "section": "",
    "text": "R utility functions used below."
  },
  {
    "objectID": "conversion.html#reading-long-format-t-matrix-files",
    "href": "conversion.html#reading-long-format-t-matrix-files",
    "title": "Conversion long/wide",
    "section": "Reading long-format T-matrix files",
    "text": "Reading long-format T-matrix files\nSome programs output T-matrices in long format, similar to the example below:\n\nd &lt;- read.table('data/tmat_Au20x40_Nmax3.tmat')\nnames(d) &lt;- c('s','sp','l','lp','m','mp','Tr','Ti')\nhead(d)\n\n  s sp l lp  m mp            Tr            Ti\n1 1  1 1  1 -1 -1 -6.049214e-05 -4.266526e-04\n2 1  1 1  1  0  0 -3.331557e-05 -3.932179e-04\n3 1  1 1  1  1  1 -6.049214e-05 -4.266526e-04\n4 1  1 1  3 -1 -1 -2.374705e-07 -1.995117e-06\n5 1  1 1  3  0  0 -1.110299e-07 -1.278537e-06\n6 1  1 1  3  1  1 -2.374705e-07 -1.995117e-06\n\n\nNote that one advantage of this format is that only non-zero entries need to be provided, similar to a sparse matrix definition. With such data, it can be useful to add combined indices \\(p\\) (blocks) and \\(q\\) (full matrix), as illustrated below:\n\nd &lt;- tmatrix_combinedindex(d)\nhead(d)\n\n  s sp l lp  m mp            Tr            Ti p pp q qp\n1 1  1 1  1 -1 -1 -6.049214e-05 -4.266526e-04 1  1 1  1\n2 1  1 1  1  0  0 -3.331557e-05 -3.932179e-04 2  2 2  2\n3 1  1 1  1  1  1 -6.049214e-05 -4.266526e-04 3  3 3  3\n4 1  1 1  3 -1 -1 -2.374705e-07 -1.995117e-06 1 11 1 11\n5 1  1 1  3  0  0 -1.110299e-07 -1.278537e-06 2 12 2 12\n6 1  1 1  3  1  1 -2.374705e-07 -1.995117e-06 3 13 3 13"
  },
  {
    "objectID": "conversion.html#convert-to-wide",
    "href": "conversion.html#convert-to-wide",
    "title": "Conversion long/wide",
    "section": "Convert to wide",
    "text": "Convert to wide\nIf we wish to convert to a true matrix representation, the following function adds all the missing zeros and places the entries at the right indices:\n\nw &lt;- tmatrix_wide(d)\n\n30 x 30 matrix of characters: \n\n                   [,1]              [,2] ...             [,30]\n[1,]  -6.0e-05-4.3e-04i  0.0e+00+0.0e+00i ...  0.0e+00+0.0e+00i\n[2,]   0.0e+00+0.0e+00i -3.3e-05-3.9e-04i ...  0.0e+00+0.0e+00i\n[3,]   0.0e+00+0.0e+00i  0.0e+00+0.0e+00i ...  0.0e+00+0.0e+00i\n...                 ...               ... ...               ...\n[30,]  0.0e+00+0.0e+00i  0.0e+00+0.0e+00i ... -6.5e-09+1.9e-07i"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "T-matrix",
    "section": "",
    "text": "Collection of scripts and self-contained examples to export/import T-matrices."
  },
  {
    "objectID": "index.html#examples-of-export-with-dummy-data",
    "href": "index.html#examples-of-export-with-dummy-data",
    "title": "T-matrix",
    "section": "Examples of export with dummy data",
    "text": "Examples of export with dummy data\n\nDoc: R • Script: R_dummy.R • Output: ar.tmat.h5\nDoc: Matlab • Script: matlab_dummy.m • Output: am.tmat.h5\nDoc: Julia • Script: julia_dummy.jl • Output: aj.tmat.h5"
  },
  {
    "objectID": "index.html#displaying-t-matrices",
    "href": "index.html#displaying-t-matrices",
    "title": "T-matrix",
    "section": "Displaying T-matrices",
    "text": "Displaying T-matrices\n\nDisplay"
  },
  {
    "objectID": "index.html#smarties-examples",
    "href": "index.html#smarties-examples",
    "title": "T-matrix",
    "section": "SMARTIES examples",
    "text": "SMARTIES examples\n\nSmarties"
  },
  {
    "objectID": "julia_export.html",
    "href": "julia_export.html",
    "title": "Export to ‘.tmat.hdf5’ format with Julia",
    "section": "",
    "text": "This document describes the process of exporting T-matrices in the standardised HDF5 format in Julia. For illustration, we start by producing a dummy dataset."
  },
  {
    "objectID": "julia_export.html#mockup-input-data",
    "href": "julia_export.html#mockup-input-data",
    "title": "Export to ‘.tmat.hdf5’ format with Julia",
    "section": "Mockup input data",
    "text": "Mockup input data\nFor convenience, we store compound objects as named tuples, which will then be mapped into HDF5 groups during export. I did not find how to link the embedding medium from materials to the top level, so it is simply duplicated.\nusing Pkg, UUIDs\n\n# possibly multiple wavelengths\nwavelength = collect(400:50:800)\nNl = length(wavelength)\n\n# dummy 30x30 matrix values for each wavelength\ntmatrix = reshape(repeat(collect(1:900.0) + collect(1:900) * 1im, Nl),\n    (30, 30, Nl))\n\nmodes = (l=collect(1:30),\n    m=collect(1:30),\n    polarisation=repeat([\"electric\", \"magnetic\"], 15))\n\n# dummy 'analytical zeros' for e.g. EBCM methods\nazeros = collect(Iterators.product(1:2:30, 1:2:30))\nanalytical_zeros = (p=[z[1] for z in azeros[:]],\n    pp=[z[2] for z in azeros[:]])\n\nembedding = (relative_permeability=1.0,\n    relative_permittivity=1.33^2)\n\nmaterials = (embedding=embedding,\n    Au=(relative_permeability=1.0,\n        relative_permittivity=-11.4 + 1.181im))\n\ngeometry = (shape=\"spheroid\",\n    radiusxy=20.0,\n    radiusz=40.0)\n\n# details about computation, including full script\ncomputation = (method=\"EBCM\",\n    software=\"SMARTIES\",\n    version=\"1.1\",\n    Ntheta=40,\n    accuracy=1e-10,\n    analytical_zeros=analytical_zeros,\n    script=read(\"test_dummy.jl\", String))\n\n\npkgs = Pkg.Operations.Context().env.manifest\nhdf5version = string(pkgs[findfirst(v -&gt; v.name == \"HDF5\", pkgs)].version)\n\nall = (vacuum_wavelength=wavelength,\n    tmatrix=tmatrix,\n    modes=modes,\n    embedding=embedding,\n    materials=materials,\n    geometry=geometry,\n    computation=computation,\n    uuid=string(UUIDs.uuid4()))"
  },
  {
    "objectID": "julia_export.html#saving-to-hdf5",
    "href": "julia_export.html#saving-to-hdf5",
    "title": "Export to ‘.tmat.hdf5’ format with Julia",
    "section": "Saving to HDF5",
    "text": "Saving to HDF5\nThe HDF5.jl library provides all the tools required, and a relatively high-level interface. Unlike R and Matlab, there does not seem to be a built-in high-level way to store list-like objects (named tuples here), so I wrote the following wrapper (defined in file _fun.jl).\nfunction write_namedtuples_to_hdf5_groups(\n    parent::Union{HDF5.File,HDF5.Group},\n    tuple::NamedTuple\n)\nComplex arrays are stored with r and i fields as usual. Note that Julia has column-major ordering, unlike HDF5, and we should therefore explicitly transpose the matrix before saving it, to avoid confusion if the data are to be read in another language.\n\nusing HDF5\n\n# custom write_dicts_to_hdf5_groups()\ninclude(\"_fun.jl\")\n\nh5open(\"aj.tmat.h5\", \"w\") do fid\n\n    # write all data in groups\n    write_namedtuples_to_hdf5_groups(fid, all)\n\n    # write custom attributes\n    attributes(fid)[\"name\"] = \"Au prolate spheroid in water\"\n    attributes(fid)[\"created_with\"] = \"HDF5.jl\"\n    attributes(fid)[\"storage_format_version\"] = hdf5version\n    attributes(fid)[\"description\"] = \"Computation using SMARTIES, a numerically robust EBCM implementation for spheroids\"\n    attributes(fid)[\"keywords\"] = \"gold, spheroid, ebcm\"\n    attributes(fid[\"vacuum_wavelength\"])[\"unit\"] = \"nm\"\n    attributes(fid[\"uuid\"])[\"version\"] = \"4\"\n    attributes(fid[\"geometry\"])[\"name\"] = \"prolate spheroid\"\n\nend"
  },
  {
    "objectID": "matlab_export.html",
    "href": "matlab_export.html",
    "title": "Export to ‘.tmat.hdf5’ format with Matlab",
    "section": "",
    "text": "This document describes a few Matlab utility functions to export T-matrices in the standardised HDF5 format. For illustration, we start by producing a dummy dataset. The SMARTIES implementation of EBCM for spheroids uses these tools internally for its HDF5 export."
  },
  {
    "objectID": "matlab_export.html#mockup-input-data",
    "href": "matlab_export.html#mockup-input-data",
    "title": "Export to ‘.tmat.hdf5’ format with Matlab",
    "section": "Mockup input data",
    "text": "Mockup input data\nThe easyh5 library takes care of most of the details for us, when objects are stored in Matlab structures. There are a couple of caveats, illustrated below, such as polarization being handled separately, and attributes being added at a later stage.\n% possibly multiple wavelengths\nwavelength  = (400:50:800)';\nNl = length(wavelength);\n\n% dummy 30x30 matrix values for each wavelength\ntdata = reshape((1:900) + 1i*(1:900), [30,30]);\ntmatrix = repmat(tdata, [1,1,Nl]);\n\n% modes, but note that polarization is handled separately\nmodes = struct('l', 1:30, 'm', 1:30); \npolarization = repmat([\"electric\",\"magnetic\"], 1, 15);\n\n% dummy 'analytical zeros' for e.g. EBCM methods\n[zerosp, zerospp] = ndgrid(1:2:30, 1:2:30);\nzeros  = struct('p', zerosp, 'pp', zerospp);\n\n% materials\nembedding = struct('relative_permeability', 1.0, ...\n                   'relative_permittivity', 1.33^2);\nparticle = struct('relative_permeability', 1.0, ...\n                  'relative_permittivity', -11.4+1.181i);\nmaterialname = 'Au'; \nmaterials = struct('embedding', embedding, materialname, particle);\n\n% geometry\ngeometry = struct('shape', 'spheroid', 'radiusxy', 20.0, 'radiusz', 40.0);\n\n% details about computation, including full script\ncomputation = struct('method','EBCM',...\n    'software','SMARTIES',...\n    'version','1.1',...\n    'Ntheta', 40, ...\n    'accuracy','1e-10', ...\n    'analytical_zeros', zeros, ...\n    'script', fileread('test_dummy.m')); % embed full script as string\n\n% combined (almost all) information into one struct\na = struct('tmatrix', tmatrix, ...\n    'vacuum_wavelength', wavelength, ...\n    'embedding', embedding,...\n    'materials', materials, ...\n    'geometry', geometry, ...\n    'modes', modes, ...\n    'computation', computation, ...\n    'uuid', char(matlab.lang.internal.uuid()));    \n\n[maj,min,rel] = H5.get_libversion();\nhdf5version = sprintf('%d.%d.%d',maj,min,rel);"
  },
  {
    "objectID": "matlab_export.html#saving-to-hdf5",
    "href": "matlab_export.html#saving-to-hdf5",
    "title": "Export to ‘.tmat.hdf5’ format with Matlab",
    "section": "Saving to HDF5",
    "text": "Saving to HDF5\naddpath(genpath('../easyh5/'));\nsaveh5 does most of the work, but we have to write polarization separately as arrays of strings within structs seem to trip easyh5. I did not find how to link the embedding medium from materials to the top level, so it is simply duplicated.\n% save to file\nf = 'am.tmat.h5';\nsaveh5(a, f, 'ComplexFormat', {'r','i'}, 'rootname', '', ...\n       'Compression', 'deflate'); % compression is optional\n\n% write polarization separately\nh5create(f,'/modes/polarization', size(polarization), 'Datatype', 'string')\nh5write(f,'/modes/polarization', polarization)\nAttributes are written in a separate step.\n% write root attributes\nh5writeatt(f, '/', 'name', 'Au prolate spheroid in water');\nh5writeatt(f, '/', 'created_with', 'Matlab easyh5');\nh5writeatt(f, '/','keywords', 'gold, spheroid, ebcm');\nh5writeatt(f, '/', 'storage_format_version', hdf5version);\nh5writeatt(f, '/','description', ...\n    'Computation using SMARTIES, a robust EBCM for spheroids');\n    \n% attributes of specific objects\nh5writeatt(f, '/vacuum_wavelength', 'unit', 'nm');\nh5writeatt(f, '/uuid', 'version', '4');\nh5writeatt(f, '/geometry', 'name', 'prolate spheroid');"
  }
]