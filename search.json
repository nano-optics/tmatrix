[
  {
    "objectID": "display.html",
    "href": "display.html",
    "title": "Displaying T-matrices with R",
    "section": "",
    "text": "R utility functions used below.\nThe following R code produces a visual heatmap of a T-matrix with a standard 2x2 block matrix layout and indexing conventions.\nExample data in long format:\n\nd &lt;- read.table('data/tmat_Au20x40_Nmax3.tmat')\nnames(d) &lt;- c('s','sp','l','lp','m','mp','Tr','Ti')\nd &lt;- tmatrix_combinedindex(d)\n\nCustom visualisation:\n\nlmax &lt;- max(d$l)\nbreaks &lt;- tmatrix_breaks(lmax)\n\np &lt;- ggplot(d, aes(q, qp, fill= log10(Mod(Tr + 1i*Ti)))) +\n  geom_raster() +\n  coord_equal() +\n  scale_fill_viridis_c(option = 'A', direction = -1) +\n  annotate('segment',x=0.5,xend=max(breaks$breaks)+0.5,y=max(breaks$breaks)/2+0.5,\n           yend=max(breaks$breaks)/2+0.5,colour='white')+\n  annotate('segment',y=0.5,yend=max(breaks$breaks)+0.5,x=max(breaks$breaks)/2+0.5,\n           xend=max(breaks$breaks)/2+0.5,colour='white')+\n  scale_y_reverse(expand=c(0,0), breaks= breaks$breaks+0.5, minor_breaks=breaks$minor_breaks+0.5, labels=breaks$labels) +\n  scale_x_continuous(expand=c(0,0), breaks= breaks$breaks+0.5, minor_breaks=breaks$minor_breaks+0.5, labels=breaks$labels) +\n  theme_minimal() +\n  theme(panel.grid = element_line(colour = 'white'), \n        panel.background = element_rect(fill='grey90',colour='white'),\n        panel.border = element_rect(colour='black',fill=NA,linewidth = 0.2),\n        axis.text.x = element_text(hjust=1),\n        axis.text.y = element_text(vjust=0)) +\n  labs(x=\"p\",y=\"p'\",fill=expression(log~\"|T|\"))\n\nprint(p)\n\n\n\n\n\n\n\n\nNote that ggplot2 makes it easy to plot multiple facets to compare different datasets,\n\n# combine data with another T-matrix from Treams\nd2 &lt;- read_treams('data/SPH-DE~4.H5')\nm &lt;- rbind(mutate(d, type = \"SMARTIES\"),\n           mutate(d2[,names(d)], type = \"Treams\"))\n\n# update the plot with these data, and facet by type\np %+% m + facet_wrap(~type)"
  },
  {
    "objectID": "export_julia.html",
    "href": "export_julia.html",
    "title": "Export to ‘.tmat.h5’ format with Julia",
    "section": "",
    "text": "This document showcases a basic Julia script to export T-matrices in the .tmat.h5 HDF5 format. For illustration, we start by producing a dummy dataset. This minimal reproducible example file is available for download as a standalone script: export_julia.jl."
  },
  {
    "objectID": "export_julia.html#mockup-input-data",
    "href": "export_julia.html#mockup-input-data",
    "title": "Export to ‘.tmat.h5’ format with Julia",
    "section": "Mockup input data",
    "text": "Mockup input data\nConsistent with the other examples, we generate a 50x30x30 array of dummy data, which repeats 50 times (50 wavelengths) a matrix of 900 entries ranging from \\(1+1i\\) (first element, top left) to \\(900 + 900i\\) (last element, bottom right). Note the expectation of row-major ordering in HDF5. The 3x3 top-left block is\n   1.0000 + 1.0000i   2.0000 + 2.0000i   3.0000 + 3.0000i ...\n  31.0000 +31.0000i  32.0000 +32.0000i  33.0000 +33.0000i ...\n  61.0000 +61.0000i  62.0000 +62.0000i  63.0000 +63.0000i ...\n   ...               ...                ...               ...\nFor convenience, we can store compound objects as named tuples, which will then be mapped into HDF5 groups during export.\n\n## mockup data\nusing Pkg, UUIDs, HDF5\n\n# possibly multiple wavelengths\nwavelength = collect(400:50:800)\nNl = length(wavelength)\nLmax = 3\nqmax = 2*(Lmax*(Lmax+1)+Lmax)\n\n# dummy 30x30 matrix values for each wavelength\n# note the row-major ordering\ntdata = transpose(reshape(collect(1:qmax^2) + collect(1:qmax^2) * 1im, (qmax,qmax)))\ntmatrix = zeros(ComplexF64,(Nl,qmax,qmax))\nfor i=1:Nl\n    tmatrix[i,:,:] = tdata\nend\n\nprint(tmatrix[1,1:3,1:3])\n\nl = zeros(Int64, qmax)\nm = zeros(Int64, qmax)\ns = Vector{String}(undef,qmax)\nlet\ni=1\nfor li = 1:Lmax\n    for mi = -li:li\n        for si = [\"electric\", \"magnetic\"]\n            l[i] = li\n            m[i] = mi\n            s[i] = si\n            i = i+1\n        end\n    end\nend\nend"
  },
  {
    "objectID": "export_julia.html#saving-to-hdf5",
    "href": "export_julia.html#saving-to-hdf5",
    "title": "Export to ‘.tmat.h5’ format with Julia",
    "section": "Saving to HDF5",
    "text": "Saving to HDF5\nComplex arrays are stored with r and i fields as usual. Note that Julia has column-major ordering, unlike HDF5, and we should therefore explicitly transpose the matrix before saving it, to avoid confusion if the data are to be read in another language. Another potential source of error is that the HDF5.jl library orders the array data differently, compared to h5py.\n\nf = \"aj.tmat.h5\"\nh5open(f, \"w\") do fid\n\n    fid[\"vacuum_wavelength\"] = wavelength\n    attributes(fid[\"vacuum_wavelength\"])[\"unit\"] = \"nm\"\n\n    # set = permutedims(dset, reverse(1:ndims(dset)))\n    # https://juliaio.github.io/HDF5.jl/stable/#Language-interoperability-with-row-and-column-major-order-arrays\n    fid[\"tmatrix\"] = permutedims(tmatrix, reverse(1:ndims(tmatrix)))\n\n    modes = create_group(fid, \"modes\") \n    modes[\"l\"] = l\n    modes[\"m\"] = m\n    modes[\"polarization\"] = s\n\n    embedding = create_group(fid, \"embedding\") \n    embedding[\"relative_permittivity\"] = 1.33^2\n    embedding[\"relative_permeability\"] = 1.0\n    attributes(embedding)[\"name\"] = \"H2O, Water\"\n    attributes(embedding)[\"keywords\"] = \"non-dispersive\"\n\n    sca_mat = create_group(fid, \"scatterer/material\") \n    sca_mat[\"relative_permittivity\"] = repeat([-11.4 + 1.181im], Nl)\n    sca_mat[\"relative_permeability\"] = 1.0\n    attributes(sca_mat)[\"name\"] = \"Au, Gold\"\n    attributes(sca_mat)[\"keywords\"] = \"dispersive, plasmonic\"\n    attributes(sca_mat)[\"reference\"] = \"Au from Raschke et al 10.1103/PhysRevB.86.235147\"\n\n    sca_geo = create_group(fid, \"scatterer/geometry\") \n    sca_geo[\"radiusxy\"] = 20.0\n    sca_geo[\"radiusz\"] = 40.0\n    attributes(sca_geo)[\"unit\"] = \"nm\"\n    attributes(sca_geo)[\"shape\"] = \"spheroid\"\n    attributes(sca_geo)[\"name\"] = \"homogeneous spheroid with symmetry axis z\"\n\n    mpar = create_group(fid, \"computation/method_parameters\") \n    mpar[\"Lmax\"] = Lmax\n    mpar[\"Ntheta\"] = 100\n    script = create_group(fid, \"computation/files\") \n    script[\"script\"] = read(\"export_julia.jl\", String)\n    \n    # write root attributes\n    attributes(fid[\"computation\"])[\"method\"] = \"EBCM, Extended Boundary Condition Method\"\n    attributes(fid[\"computation\"])[\"description\"] = \"Computation using SMARTIES, a numerically robust EBCM implementation for spheroids\"\n    attributes(fid[\"computation\"])[\"software\"] = \"SMARTIES\"\n    attributes(fid[\"computation\"])[\"name\"] = \"SMARTIES\"\n    attributes(fid[\"computation\"])[\"version\"] = \"1.1\"\n\n    attributes(fid)[\"name\"] = \"Au prolate spheroid in water\"\n    attributes(fid)[\"description\"] = \"Computation using SMARTIES, a numerically robust EBCM implementation for spheroids\"\n    attributes(fid)[\"keywords\"] = \"gold, spheroid, ebcm, passive, reciprocal, czinfinity, mirrorxyz\"    \n    attributes(fid)[\"storage_format_version\"] = \"v0.01\"\n    \nend\n\n\nSummary of the file:\n&lt;list&gt;\n├─data: &lt;list&gt;\n│ ├─computation: &lt;list&gt;\n│ │ ├─files: &lt;list&gt;\n│ │ │ └─script: \"## mockup data↵using Pkg, UUIDs,...\"\n│ │ └─method_parameters: &lt;list&gt;\n│ │   ├─Lmax: 3\n│ │   └─Ntheta: 100\n│ ├─embedding: &lt;list&gt;\n│ │ ├─relative_permeability: 1\n│ │ └─relative_permittivity: 1.7689\n│ ├─modes: &lt;list&gt;\n│ │ ├─l&lt;int [30]&gt;: 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, ...\n│ │ ├─m&lt;int [30]&gt;: -1, -1, 0, 0, 1, 1, -2, -2, -1, -1, ...\n│ │ └─polarization&lt;chr [30]&gt;: \"electric\", \"magnetic\", \"electric\", \"magnetic\", \"electric\", \"magnetic\", \"electric\", \"magnetic\", \"electric\", \"magnetic\", ...\n│ ├─scatterer: &lt;list&gt;\n│ │ ├─geometry: &lt;list&gt;\n│ │ │ ├─radiusxy: 20\n│ │ │ └─radiusz: 40\n│ │ └─material: &lt;list&gt;\n│ │   ├─relative_permeability: 1\n│ │   └─relative_permittivity&lt;cpl [9]&gt;: -11.4+1.181i, -11.4+1.181i, -11.4+1.181i, -11.4+1.181i, -11.4+1.181i, -11.4+1.181i, -11.4+1.181i, -11.4+1.181i, -11.4+1.181i\n│ ├─tmatrix&lt;cpl [8,100]&gt;: 1+1i, 1+1i, 1+1i, 1+1i, 1+1i, 1+1i, 1+1i, 1+1i, 1+1i, 31+31i, ...\n│ └─vacuum_wavelength&lt;int [9]&gt;: 400, 450, 500, 550, 600, 650, 700, 750, 800\n└─attributes: &lt;list&gt;\n  ├─root: &lt;list&gt;\n  │ ├─description: \"Computation using SMARTIES, a nu...\"\n  │ ├─keywords: \"gold, spheroid, ebcm, passive, r...\"\n  │ ├─name: \"Au prolate spheroid in water\"\n  │ └─storage_format_version: \"v0.01\"\n  ├─vacuum_wavelength: &lt;list&gt;\n  │ └─unit: \"nm\"\n  ├─computation: &lt;list&gt;\n  │ ├─description: \"Computation using SMARTIES, a nu...\"\n  │ ├─method: \"EBCM, Extended Boundary Conditio...\"\n  │ ├─name: \"SMARTIES\"\n  │ ├─software: \"SMARTIES\"\n  │ └─version: \"1.1\"\n  ├─embedding: &lt;list&gt;\n  │ ├─keywords: \"non-dispersive\"\n  │ └─name: \"H2O, Water\"\n  ├─material: &lt;list&gt;\n  │ ├─keywords: \"dispersive, plasmonic\"\n  │ ├─name: \"Au, Gold\"\n  │ └─reference: \"Au from Raschke et al 10.1103/Ph...\"\n  └─geometry: &lt;list&gt;\n    ├─name: \"homogeneous spheroid with symmet...\"\n    ├─shape: \"spheroid\"\n    └─unit: \"nm\""
  },
  {
    "objectID": "indexing.html",
    "href": "indexing.html",
    "title": "Indexing conventions",
    "section": "",
    "text": "The convention is to use\n\nm: multipole order, -l:l\nl: multipole degree 1:lmax\ns: multipole polarisation type, 1 or 2\n\nso for a T-matrix with \\(lmax=3\\), we have\n\n\nl: 1..3\nm: -3..3\ns: 1..2\n900 elements\n\n\n\n\n\n\n\n\n\nfor each block we introduce a combined p-index such that,\n\\[\np(n,m) = n(n+1)+m\n\\] which here varies as p: 1..15, as each block is of dimension pmax = lmax(lmax+1)+lmax = 3(3+1)+3 = 15.\nThe whole T-matrix is indexed with a combined q-index such that,\n\\[\nq(s,p) = (s-1)p_{max} + p\n\\] which here gives us, q: 1..30. The total T-matrix dimension (along rows/columns) is thus \\(q_{max}=2\\times(lmax(lmax+1)+lmax)=30\\).\nIn summary, for a given \\(l_\\text{max}\\) the indices are given by:\n\n\\(l=1:l_\\text{max}\\)\n\\(m=-l:l\\) for each l\n\\(s=1:2\\) for each pair of (l,m)\n\\(p(l,m) = l(l+1)+m\\)\n\\(q(s,p) = (s-1)p_{max} + p\\)\n\nGiven \\(q\\) and \\(l_\\text{max}\\) we can invert these indices as follows,\n\n\\(p = q - (s-1)q_\\text{max}/2\\),\ngiving here, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15\n\\(l = \\lfloor\\sqrt{p}\\rfloor\\),\ngiving here 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3\n\\(m = p - l(l+1)\\),\ngiving here -1, 0, 1, -2, -1, 0, 1, 2, -3, -2, -1, 0, 1, 2, 3, -1, 0, 1, -2, -1, 0, 1, 2, -3, -2, -1, 0, 1, 2, 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n\np\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nl\n1\n1\n1\n2\n2\n2\n2\n2\n3\n3\n3\n3\n3\n3\n3\n1\n1\n1\n2\n2\n2\n2\n2\n3\n3\n3\n3\n3\n3\n3\n\n\nm\n-1\n0\n1\n-2\n-1\n0\n1\n2\n-3\n-2\n-1\n0\n1\n2\n3\n-1\n0\n1\n-2\n-1\n0\n1\n2\n-3\n-2\n-1\n0\n1\n2\n3\n\n\ns\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2"
  },
  {
    "objectID": "smarties_batch.html",
    "href": "smarties_batch.html",
    "title": "Calculating many SMARTIES T-matrices",
    "section": "",
    "text": "Below is an example script to run many SMARTIES simulations and export the T-matrices in HDF5. The script is available as standalone script smarties_batch.R.\n\nlibrary(glue)\nlibrary(dplyr)\nlibrary(purrr)\n\n# read in the template\ntemplate &lt;- glue_collapse(readLines('smarties/_template.m'), sep = \"\\n\")\n\nparameters &lt;- expand.grid(a = seq(10, 100, by=5), c = seq(10, 100, by=5),\n                          material = c(\"Au\", \"Ag\", \"Si\"), \n                          medium = c(\"vacuum\", \"water\")) |&gt; \n  filter(a != c) |&gt; # use Mie for this\n  mutate(shape = ifelse(a &gt; c, \"oblate\", \"prolate\"),\n         n = ifelse(medium == \"water\", 1.33, 1.0),\n         source = case_when(material == \"Au\" ~ \"Raschke et al 10.1103/PhysRevB.86.235147\", \n                            material == \"Ag\" ~ \"Raschke et al 10.1103/PhysRevB.91.235137\",\n                            material == \"Si\" ~ \"Aspnes et al 10.1103/PhysRevB.27.985\",\n                            .default = \"Unknown material!\"))\n\nparameters$step &lt;- 1\nnrow(parameters)\n\n[1] 2052\n\n\nFor initial testing, we’ll run much fewer combinations\n\nparameters &lt;- expand.grid(a = seq(20, 50, by=10), c = seq(20, 50, by=10),\n                          material = c(\"Au\", \"Ag\"), \n                          medium = c(\"water\")) |&gt; \n  filter(a != c) |&gt; # use Mie for this\n  mutate(shape = ifelse(a &gt; c, \"oblate\", \"prolate\"),\n         n = ifelse(medium == \"water\", 1.33, 1.0),\n         source = case_when(material == \"Au\" ~ \"Raschke et al 10.1103/PhysRevB.86.235147\", \n                            material == \"Ag\" ~ \"Raschke et al 10.1103/PhysRevB.91.235137\",\n                            material == \"Si\" ~ \"Aspnes et al 10.1103/PhysRevB.27.985\",\n                            .default = \"Unknown material!\"))\nparameters$step &lt;- 5\n\nEven with these restricted options, there’s already 24 combinations.\n\n\n\n\n\n\n\n\n\na\nc\nshape\nmaterial\nmedium\n\n\n\n\n30\n20\noblate\nAu\nwater\n\n\n40\n20\noblate\nAu\nwater\n\n\n50\n20\noblate\nAu\nwater\n\n\n20\n30\nprolate\nAu\nwater\n\n\n40\n30\noblate\nAu\nwater\n\n\n50\n30\noblate\nAu\nwater\n\n\n20\n40\nprolate\nAu\nwater\n\n\n30\n40\nprolate\nAu\nwater\n\n\n50\n40\noblate\nAu\nwater\n\n\n20\n50\nprolate\nAu\nwater\n\n\n30\n50\nprolate\nAu\nwater\n\n\n40\n50\nprolate\nAu\nwater\n\n\n30\n20\noblate\nAg\nwater\n\n\n40\n20\noblate\nAg\nwater\n\n\n50\n20\noblate\nAg\nwater\n\n\n20\n30\nprolate\nAg\nwater\n\n\n40\n30\noblate\nAg\nwater\n\n\n50\n30\noblate\nAg\nwater\n\n\n20\n40\nprolate\nAg\nwater\n\n\n30\n40\nprolate\nAg\nwater\n\n\n50\n40\noblate\nAg\nwater\n\n\n20\n50\nprolate\nAg\nwater\n\n\n30\n50\nprolate\nAg\nwater\n\n\n40\n50\nprolate\nAg\nwater\n\n\n\n\n\n\n\n\nWe use the “glue” package to inject the parameters into the template, where the variables are indicated between braces {}. The process loops over each parameter combination and outputs a new file with corresponding filename.\n\nwrite_script &lt;- function(a, c, material, medium, shape, n, step, source){\n script &lt;- glue(template)   \n cat(script, file = glue('smarties/run_{material}_{medium}_{a}_{c}.m'))\n cat(glue(\"run_{material}_{medium}_{a}_{c}\\n\\n\"), \n     file = \"smarties/batch.m\", append = TRUE)\n}\n cat(\"%% Running all the files below\\n\",file = \"smarties/batch.m\", append = FALSE)\npwalk(rowwise(parameters), write_script)\n\nRunning the batch script in Matlab results in 24 output T-matrix files of size between 4 and 6Mb each, with the 5nm step defined above. The value of Lmax needed for \\(10^{-10}\\) accuracy in \\(\\langle\\sigma_\\text{ext}\\rangle\\) appears to be around 11."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "conversion.html",
    "href": "conversion.html",
    "title": "Conversion long/wide",
    "section": "",
    "text": "R utility functions used below."
  },
  {
    "objectID": "conversion.html#reading-long-format-t-matrix-files",
    "href": "conversion.html#reading-long-format-t-matrix-files",
    "title": "Conversion long/wide",
    "section": "Reading long-format T-matrix files",
    "text": "Reading long-format T-matrix files\nSome programs output T-matrices in long format, similar to the example below:\n\nd &lt;- read.table('data/tmat_Au20x40_Nmax3.tmat')\nnames(d) &lt;- c('s','sp','l','lp','m','mp','Tr','Ti')\nhead(d)\n\n  s sp l lp  m mp            Tr            Ti\n1 1  1 1  1 -1 -1 -6.049214e-05 -4.266526e-04\n2 1  1 1  1  0  0 -3.331557e-05 -3.932179e-04\n3 1  1 1  1  1  1 -6.049214e-05 -4.266526e-04\n4 1  1 1  3 -1 -1 -2.374705e-07 -1.995117e-06\n5 1  1 1  3  0  0 -1.110299e-07 -1.278537e-06\n6 1  1 1  3  1  1 -2.374705e-07 -1.995117e-06\n\n\nNote that one advantage of this format is that only non-zero entries need to be provided, similar to a sparse matrix definition. With such data, it can be useful to add combined indices \\(p\\) (blocks) and \\(q\\) (full matrix), as illustrated below:\n\nd &lt;- tmatrix_combinedindex(d)\nhead(d)\n\n  s sp l lp  m mp            Tr            Ti p pp q qp\n1 1  1 1  1 -1 -1 -6.049214e-05 -4.266526e-04 1  1 1  1\n2 1  1 1  1  0  0 -3.331557e-05 -3.932179e-04 2  2 2  2\n3 1  1 1  1  1  1 -6.049214e-05 -4.266526e-04 3  3 3  3\n4 1  1 1  3 -1 -1 -2.374705e-07 -1.995117e-06 1 11 1 11\n5 1  1 1  3  0  0 -1.110299e-07 -1.278537e-06 2 12 2 12\n6 1  1 1  3  1  1 -2.374705e-07 -1.995117e-06 3 13 3 13"
  },
  {
    "objectID": "conversion.html#reading-wide-data-and-converting-to-long-format",
    "href": "conversion.html#reading-wide-data-and-converting-to-long-format",
    "title": "Conversion long/wide",
    "section": "Reading wide data and converting to long format",
    "text": "Reading wide data and converting to long format\nThe function read_treams() reads a standard HDF5-stored T-matrix and returns it in long format, including the computation’s method_parameters fields.\n\nd &lt;- read_treams('data/SPH-DE~4.H5')\nhead(d)\n\n  s sp l lp  m mp            Tr            Ti          mod p pp q qp domain_x\n1 1  1 1  1 -1 -1 -5.907953e-05 -4.253829e-04 4.294659e-04 1  1 1  1      633\n2 1  1 1  1  0  0 -3.230918e-05 -3.810847e-04 3.824519e-04 2  2 2  2      633\n3 1  1 1  1  1  1 -5.907953e-05 -4.253829e-04 4.294659e-04 3  3 3  3      633\n4 1  1 1  2 -1 -1  5.408062e-10 -4.834050e-09 4.864207e-09 1  5 1  5      633\n5 1  1 1  2  0  0 -1.995470e-11 -3.206499e-09 3.206561e-09 2  6 2  6      633\n6 1  1 1  2  1  1  5.408062e-10 -4.834050e-09 4.864207e-09 3  7 3  7      633\n  domain_y domain_z fem_degree max_refinements maximumSideLength\n1      633      633          2               1                13\n2      633      633          2               1                13\n3      633      633          2               1                13\n4      633      633          2               1                13\n5      633      633          2               1                13\n6      633      633          2               1                13\n  maximumSideLengthDomain precision\n1                      13     1e-05\n2                      13     1e-05\n3                      13     1e-05\n4                      13     1e-05\n5                      13     1e-05\n6                      13     1e-05"
  },
  {
    "objectID": "conversion.html#convert-to-wide",
    "href": "conversion.html#convert-to-wide",
    "title": "Conversion long/wide",
    "section": "Convert to wide",
    "text": "Convert to wide\nIf we wish to convert to a true matrix representation, the following function adds all the missing zeros and places the entries at the combined indices \\((q,q')\\),\n\nw &lt;- tmatrix_wide(d)\n\n30 x 30 matrix of characters: \n\n                   [,1]              [,2] ...             [,30]\n[1,]  -5.9e-05-4.3e-04i  0.0e+00+0.0e+00i ...  0.0e+00+0.0e+00i\n[2,]   0.0e+00+0.0e+00i -3.2e-05-3.8e-04i ...  0.0e+00+0.0e+00i\n[3,]   0.0e+00+0.0e+00i  0.0e+00+0.0e+00i ...  0.0e+00+0.0e+00i\n...                 ...               ... ...               ...\n[30,]  0.0e+00+0.0e+00i  0.0e+00+0.0e+00i ... -6.4e-09+1.7e-07i"
  },
  {
    "objectID": "manuscript/blurb.html",
    "href": "manuscript/blurb.html",
    "title": "T-matrix",
    "section": "",
    "text": "== SMARTIES\nThe original T-matrix method, devised by Waterman [ref], introduced alongside a specific calculation scheme – the Extended Boundary Condition Method. This technique has strong analytical roots, requiring no meshing of the particle’s volume or surface and, instead, computes T-matrix elements via analytical formulas which reduce to Mie theory for spherical particles [ref]. For other shapes, the computation requires integration over the particle surface, by numerical quadrature. For axi-symmetric particles, the method is remarkably efficient as the matrix elements are obtained via simple one-dimensional integrals. The EBCM method is particularly popular for simple geometrical shapes, where it typically provides the fastest and most accurate way to calculate a T-matrix [ref].\nSMARTIES is a Matlab implementation of the EBCM to simulate the optical properties of oblate and prolate spheroidal particles, with comparable speed, convenience and accuracy as Mie theory for spheres. SMARTIES is only applicable to spheroidal particles, for which it uses an improved algorithm that overcomes some of the numerical difficulties related to loss of precision faced by EBCM in the case of large and elongated particles [ref]. The code may be useful to researchers seeking a fast, accurate and reliable tool to simulate the near-field and far-field optical properties of elongated particles, but can also appeal to other developers of light-scattering software seeking a reliable benchmark for non-spherical particles with a challenging aspect ratio and/or refractive index contrast.\nWe provide below an example script to output the T-matrix of a gold spheroid, used in the calculation of Figure XX.\nwavelength = 600:50:800; wavelength = wavelength(:); \nNl = length(wavelength);\nepsilon=epsAu(wavelength);\nmedium=1.33;\n\n% constant simulation parameters\nstParams.a=20;\nstParams.c=40;\nstParams.N=3; \nstParams.nNbTheta=90;\n% internal options\nstOptions.bGetR = false;\n\n%% calculation for all wavelengths\n\n% allocate 3D array for all results\nqmax = 2*(stParams.N*(stParams.N + 1) + stParams.N); % size of full T-matrix\ntmatrix = zeros(qmax, qmax, Nl);\n\n% indices in TERMS order (2x2 blocks)\nvecq = 1:qmax;\nvecs = [repmat(1,1, qmax/2), repmat(2,1, qmax/2)];\nvecp = vecq - (vecs - 1) * qmax/2;\nvecl = floor(sqrt(vecp));\nvecm = vecp - vecl.*(vecl + 1);\n\n% loop over wavelengths\nfor i=1:Nl\n    stParams.k1=medium*2*pi/wavelength(i);\n    stParams.s=sqrt(epsilon(i)) / medium;\n\n    [stCoa, stT] = slvForT(stParams,stOptions);\n\n    [T, q, qp] = exportTmatrix( stT, true, [], [] );\n    % q, qp are the row,col indices in TERMS convention\n    % converted to u, up for treams conventions\n    [u] = treams_indexing(q, qmax);\n    [up] = treams_indexing(qp, qmax);\n    ind = sub2ind(size(tmatrix),u,up,u*0+i); \n    % which linear index for elements (u,u',lambdai)\n    tmatrix(ind) =  T(:,7) + 1i*T(:,8);\n\nend\n\n% analytical zeros are those entries SMARTIES did not need to compute\nnonzeros = sub2ind([qmax,qmax],q,qp);\nzeros = setdiff((1:qmax^2)', nonzeros);\n[zerosq, zerosqp] = ind2sub([qmax,qmax], zeros);\nzeros  = struct('q', int64(zerosq), 'qp', int64(zerosqp));\n\n%% data to export\npolars = [\"electric\",\"magnetic\"];\nmodes = struct('l', int64(vecl),'m', int64(vecm), 'polarization', polars(vecs));\n\nepsilon = struct('embedding', medium^2, 'spheroid', epsilon);\ngeometry = struct('spheroid', struct('radiusxy', stParams.a, 'radiusz', stParams.c));\nmethod_parameters = struct('Lmax', int64(stParams.N), ...\n                           'Ntheta', int64(stParams.nNbTheta));\ncomputation = struct('method_parameters', method_parameters, ...\n                     'analytical_zeros', zeros);\n\ncomments = struct('name', 'Au prolate spheroid in water',...\n    'description', 'Computation using SMARTIES, a numerically robust EBCM implementation for spheroids',...\n    'material_reference', 'Au from Raschke et al 10.1103/PhysRevB.86.235147', ...\n    'material_spheroid', 'gold', ...,\n    'material_embedding', 'water', ...,\n    'keywords', 'gold, spheroid, ebcm', ...\n    'script', [mfilename '.m']);\n\n[f, uuid] = tmatrix_hdf5('smarties_spectrum.tmat.h5', tmatrix, modes, wavelength, epsilon, geometry, computation, comments)\n== TERMS\nTERMS is a Fortran program based on the superposition T-matrix method, designed to simulate the near-field and far-field optical properties of collections of particles [ref]. It was developed primarily to model relatively compact clusters of resonant scatterers, such as plasmonic particles often requiring large multipolar orders [ref]. TERMS implements several independent algorithms, with complementary strengths and weaknesses, to describe the self-consistent electromagnetic interaction between multiple scatterers, and from there compute far-field optical properties such as absorption, scattering, extinction, circular dichroism, as well as near-field intensities and the local degree of optical chirality. By describing the incident and scattered fields in a basis of spherical waves the T-matrix framework lends itself to analytical formulas for orientation-averaged quantities such as far-field cross-sections and near-field quantities, greatly reducing the computational time needed to simulate particles and systems of particles in random orientation [ref].\nEach scatterer is described by a T-matrix, which is computed internally for spherical particles (including layered spheres), or using external files computed with any other method.\nTERMS computations are divided into three main modes:\n\nFar-field quantities (absorption, scattering, extinction, circular dichroism) for multiple wavelengths and angles of incidence, as well as orientation-averages\nNear-field calculations for multiple wavelengths and incident angles, also computing the local degree of chirality, as well as orientation-averages\nStokes parameters and differential scattering cross-sections for multiple incidence or scattering angles\n\nThe program’s documentation and website offer many examples of use [ref]; for the purpose of this work we only illustrate the import of an external T-matrix in the tmat.h5 format. The input file for the simulation reproduced below considers two gold spheroids in water, separated by 100 nm and rotated by 45 degrees to form a chiral structure.\nModeAndScheme 2 3\nMultipoleCutoff 5\nWavelength 400 800 200\nMedium 1.7689 # water\n\n# dimer of Au spheroids\nScatterers 2\nTF1 0 -50 0.0 50 0.0 0.0 0.0  2.5\nTF1 0  50 0.0 50 0.0 0.7853982 0  2.5\nThe simulation is run with the command\nterms input &gt; log\nand outputs cross-sections in the file results.h5, displayed in Figure XX. For comparison, the same simulation was run with a T-matrix produced by SMARTIES (Script XX) for the same geometry.\n= Tools for conversion\nA number of open-source programs are available to compute T-matrices, but many of them do not (yet) implement the output format presented herein. While we encourage the community to add this functionality in order to fully benefit from interoperability between programs, it can also be useful, as a short-term or one-time workaround, to convert T-matrix data stored in a different form. One example is the “long format” used to store T-matrix entries in earlier versions of SMARTIES [ref], or Scuff-EM [ref], or PXTAL [ref]. We include example scripts at [url] to reshape such data and produce a standard h5 format.\nd = read.table('data/tmat_Au20x40_Nmax3.tmat')\nnames(d) = c('s','sp','l','lp','m','mp','Tr','Ti')\nhead(d)\n  s sp l lp  m mp            Tr            Ti\n1 1  1 1  1 -1 -1 -6.049214e-05 -4.266526e-04\n2 1  1 1  1  0  0 -3.331557e-05 -3.932179e-04\n3 1  1 1  1  1  1 -6.049214e-05 -4.266526e-04\n4 1  1 1  3 -1 -1 -2.374705e-07 -1.995117e-06\n5 1  1 1  3  0  0 -1.110299e-07 -1.278537e-06\n6 1  1 1  3  1  1 -2.374705e-07 -1.995117e-06\nConversion to wide format, and export as .tmat.h5, can then be done by adding the required geometry and material information to make a complete entry. Basic export scripts are available in 4 different languages (R, Julia, Matlab, Python) to serve as examples for similar conversion tasks."
  },
  {
    "objectID": "smarties.html",
    "href": "smarties.html",
    "title": "Exporting SMARTIES T-matrices",
    "section": "",
    "text": "Below is an example script to run many SMARTIES simulations and export the T-matrices in HDF5. The script is available as standalone script smarties.m.\nSMARTIES provides some functions to estimate the maximum multipolar order and number of quadrature points required to reach a desired accuracy. We choose here to fix the relative accuracy to \\(10^{-10}\\) for the orientation-averaged extinction cross-section, which results in higher \\(lmax\\) values for larger and/or more elongated spheroids.\n\npath(pathdef); % clear previous path changes\naddpath(genpath('~/Documents/nano-optics/smarties/'));\naddpath(genpath('~/Documents/nano-optics/easyh5/'));\nclearvars;\n\n%% example\n\n% requested precision (OA Cext)\naccuracy = 1e-10;\n\n% prolate Au spheroid in water\n% semi-axes a=b=20nm, c=40nm\nwavelength = 600:50:800; wavelength = wavelength(:); \nNl = length(wavelength);\nepsilon=epsAu(wavelength);\nmedium=1.33;\n\n% constant simulation parameters\nstParams.a=20;\nstParams.c=40;\n\n% internal options\nstOptions.bGetR = false;\nstOptions.Delta = 0;\nstOptions.NB = 0; % NB will be estimated automatically\nstOptions.bGetSymmetricT = false;\nstOptions.bOutput = false; % verbosity\n\nWe first figure out the maximum convergence parameters required\n\n\nglobalN = 1;\nglobalnNbTheta = 1;\n\nfor i=1:Nl\n    stParams.k1=medium*2*pi/wavelength(i);\n    stParams.s=sqrt(epsilon(i)) / medium;\n    % Estimated convergence params\n    [N, nNbTheta] = sphEstimateNandNT(stParams, stOptions, accuracy);\n    stParams.N=N; stParams.nNbTheta=nNbTheta;\n    % Increase params to test accuracy\n    stParams2=stParams;\n    stParams2.N=stParams2.N+5;\n    stParams2.nNbTheta=stParams2.nNbTheta+5;\n\n    [stCoa, stT] = slvForT(stParams,stOptions);\n    [stCoa2, stT2] = slvForT(stParams2,stOptions);\n\n    if(stOptions.bOutput)\n        fprintf('Convergence testing... lambda = %.5g\\n', wavelength(i));\n        fprintf('&lt;Cext&gt; = %.10g,   relative error: %.2g\\n', stCoa.Cext, abs(stCoa.Cext./stCoa2.Cext-1));\n        fprintf('&lt;Csca&gt; = %.10g,   relative error: %.2g\\n', stCoa.Csca, abs(stCoa.Csca./stCoa2.Csca-1));\n        fprintf('&lt;Cabs&gt; = %.10g,   relative error: %.2g\\n', stCoa.Cabs, abs(stCoa.Cabs./stCoa2.Cabs-1));\n    end\n\n    if(abs(stCoa.Cext./stCoa2.Cext-1) &gt; 1.1*accuracy)\n        warning('requested precision was not achieved')\n    end\n\n    globalN = max(globalN, stParams.N);\n    globalnNbTheta = max(globalnNbTheta, stParams.nNbTheta);\nend\n\nNext, we redo the calculations for all wavelengths with these fixed parameters.\n\n\n% allocate 3D array for all results\nqmax = 2*(globalN*(globalN + 1) + globalN );\ntmatrix = zeros(qmax, qmax, Nl);\n\nfor i=1:Nl\n    stParams.k1=medium*2*pi/wavelength(i);\n    stParams.s=sqrt(epsilon(i)) / medium;\n\n    stParams.N=globalN; stParams.nNbTheta=globalnNbTheta;\n\n    [stCoa, stT] = slvForT(stParams,stOptions);\n\n    [T, q, qp] = exportTmatrix( stT, true, [], [] );\n    ind = sub2ind(size(tmatrix),q,qp,q*0+i);\n    tmatrix(ind) =  T(:,7) + 1i*T(:,8);\n\nend\n\nFinally, we export the data into HDF5.\n\nvecq = 1:qmax;\nvecs = [repmat(1,1, qmax/2), repmat(2,1, qmax/2)];\nvecp = vecq - (vecs - 1) * qmax/2;\nvecl = floor(sqrt(vecp));\nvecm = vecp - vecl.*(vecl + 1);\n\n\npolars = [\"electric\",\"magnetic\"];\nmodes = struct('l', int16(vecl),'m', int16(vecm), 'polarization', polars(vecs));\n\nepsilon = struct('embedding', medium^2, 'Au', epsilon);\n\ngeometry = struct('description',  'prolate spheroid', ...\n    'shape', 'spheroid','radiusxy', stParams.a, 'radiusz', stParams.c);\n\ncomputation = struct('method','EBCM',...\n    'software','SMARTIES',...\n    'version','1.1',...\n    'unit','nm', ...\n    'Lmax', globalN, ...\n    'Ntheta', globalnNbTheta, ...\n    'accuracy', accuracy);\n\ncomments = struct('name', 'Au prolate spheroid in water',...\n    'description', 'Computation using SMARTIES, a numerically robust EBCM implementation for spheroids',...\n    'sources', 'Au from Raschke et al 10.1103/PhysRevB.86.235147',...\n    'keywords', 'gold, spheroid, ebcm', ...\n    'script', [mfilename '.m']);\n\n\n[f, uuid] = tmatrix_hdf5('smarties_spectrum.tmat.h5', tmatrix, modes, wavelength, epsilon, geometry, computation, comments)\n\nOutput file: smarties_spectrum.tmat.h5"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "T-matrix",
    "section": "",
    "text": "Collection of scripts and self-contained examples to export/import T-matrices."
  },
  {
    "objectID": "index.html#examples-of-export-with-dummy-data",
    "href": "index.html#examples-of-export-with-dummy-data",
    "title": "T-matrix",
    "section": "Examples of export with dummy data",
    "text": "Examples of export with dummy data\n\nDoc: Julia • Script: export_julia.jl • Output: aj.tmat.h5\nDoc: Matlab • Script: export_matlab.m • Output: am.tmat.h5\nDoc: Python • Script: export_python.py • Output: ap.tmat.h5\nDoc: R • Script: export_R.R • Output: ar.tmat.h5"
  },
  {
    "objectID": "index.html#misc.-utilities",
    "href": "index.html#misc.-utilities",
    "title": "T-matrix",
    "section": "Misc. utilities",
    "text": "Misc. utilities\n\nConversion\nDisplay\nIndexing"
  },
  {
    "objectID": "index.html#smarties-examples",
    "href": "index.html#smarties-examples",
    "title": "T-matrix",
    "section": "SMARTIES examples",
    "text": "SMARTIES examples\n\nDoc: Smarties • Script: smarties.m • Output: smarties_spectrum.tmat.h5\nBatch example: smarties_batch"
  },
  {
    "objectID": "export_matlab.html",
    "href": "export_matlab.html",
    "title": "Export to ‘.tmat.h5’ format with Matlab",
    "section": "",
    "text": "This document showcases a basic Matlab script to export T-matrices in the .tmat.h5 HDF5 format. For illustration, we start by producing a dummy dataset. This minimal reproducible example file is available for download as a standalone script: export_matlab.m."
  },
  {
    "objectID": "export_matlab.html#mockup-input-data",
    "href": "export_matlab.html#mockup-input-data",
    "title": "Export to ‘.tmat.h5’ format with Matlab",
    "section": "Mockup input data",
    "text": "Mockup input data\nConsistent with the other examples, we generate a 50x30x30 array of dummy data, which repeats 50 times (50 wavelengths) a matrix of 900 entries ranging from \\(1+1i\\) (first element, top left) to \\(900 + 900i\\) (last element, bottom right). Note the expectation of row-major ordering in HDF5. The 3x3 top-left block is\n   1.0000 + 1.0000i   2.0000 + 2.0000i   3.0000 + 3.0000i ...\n  31.0000 +31.0000i  32.0000 +32.0000i  33.0000 +33.0000i ...\n  61.0000 +61.0000i  62.0000 +62.0000i  63.0000 +63.0000i ...\n   ...               ...                ...               ...\nThe easyh5 library takes care of most of the details for us, when objects are stored in Matlab structures. There are a couple of caveats, illustrated below, such as polarization being handled separately, and attributes being added at a later stage.\n\n% possibly multiple wavelengths\nwavelength  = (400:50:800)';\nNl = length(wavelength);\n\nLmax = 3;\nqmax = 2*(Lmax*(Lmax+1)+Lmax); % T-matrix size\n\n% dummy 30x30 matrix values for each wavelength\n% note the transpose due to HDF5 expecting\n% row-major ordering vs matlab's default column-major\ntdata = transpose(reshape((1:qmax^2) + 1i*(1:qmax^2), [qmax,qmax]));\n\ntmatrix = zeros(Nl,qmax,qmax);\nfor i=1:Nl\n    tmatrix(i,:,:) = tdata;\nend\n\nsqueeze(tmatrix(1,1:3,1:3))\n\n% modes, but note that polarization is turned into strings separately\ni=1;\nfor l=1:3\n    for m=-l:l\n        for s=1:2\n            modes.l(i) = int64(l);\n            modes.m(i) = int64(m);\n            modes.s(i) = int64(s);\n            i=i+1;\n        end\n    end\nend\npolars = [\"electric\",\"magnetic\"];\npolarization = polars(modes.s);\nmodes = rmfield(modes,'s');\n\n% dummy 'analytical zeros' for e.g. EBCM methods\n% [zerosq, zerosqp] = ndgrid(1:2:30, 1:2:30);\n% zeros  = struct('q', zerosq, 'qp', zerosqp);\n\n% materials\nembedding = struct('relative_permeability', 1.0, ...\n                   'relative_permittivity', 1.33^2);\nparticle = struct('relative_permeability', 1.0, ...\n                  'relative_permittivity', repmat(-11.4+1.181i, [Nl,1]));\n\n% geometry\ngeometry = struct('radiusxy', 20.0, 'radiusz', 40.0);\n\nscatterer = struct('material', particle, ...\n                  'geometry', geometry);\n\n% details about computation\n\nmethod_parameters = struct('Lmax', int64(3), ...\n                           'Ntheta', int64(100));\n\ncomputation = struct('method_parameters', method_parameters);\n% 'analytical_zeros', zeros can be added here\n\nscript = convertCharsToStrings(fileread('export_matlab.m'));\n\n% combined (almost all) information into one struct\ns = struct('tmatrix', tmatrix, ...\n    'vacuum_wavelength', wavelength, ...\n    'embedding', embedding,...\n    'scatterer', scatterer, ...\n    'modes', modes, ...\n    'computation', computation);"
  },
  {
    "objectID": "export_matlab.html#saving-to-hdf5",
    "href": "export_matlab.html#saving-to-hdf5",
    "title": "Export to ‘.tmat.h5’ format with Matlab",
    "section": "Saving to HDF5",
    "text": "Saving to HDF5\n\naddpath(genpath('../easyh5/'));\n\nsaveh5 does most of the work, but we have to write polarization and script separately as strings within structs seem to trip easyh5.\n\nf = 'am.tmat.h5';\nsaveh5(s, f, 'ComplexFormat', {'r','i'}, 'rootname', '', 'Compression', 'deflate'); \n\n% deal with string objects manually\nh5create(f,'/computation/files/script', size(script), 'Datatype', 'string')\nh5write(f,'/computation/files/script', script)\n\nh5create(f,'/modes/polarization', size(polarization), 'Datatype', 'string')\nh5write(f,'/modes/polarization', polarization)\n\n% root attributes\nh5writeatt(f, '/', 'name', 'Au prolate spheroid in water');\nh5writeatt(f, '/', 'storage_format_version', 'v0.01'); \nh5writeatt(f, '/','description', ...\n    'Computation using SMARTIES, a numerically robust EBCM implementation for spheroids');\nh5writeatt(f, '/','keywords', 'gold, spheroid, ebcm, passive, reciprocal, czinfinity, mirrorxyz');\n\n% object and group attributes\nh5writeatt(f, '/vacuum_wavelength', 'unit', 'nm');\n\nh5writeatt(f, '/embedding', 'keywords', 'non-dispersive');\nh5writeatt(f, '/embedding', 'name', 'H2O, Water');\n\nh5writeatt(f, '/scatterer/material', 'name', 'Au, Gold');\nh5writeatt(f, '/scatterer/material', 'reference', 'Au from Raschke et al 10.1103/PhysRevB.86.235147');\nh5writeatt(f, '/scatterer/material', 'keywords', 'dispersive, plasmonic');\n\nh5writeatt(f, '/scatterer/geometry', 'name', 'homogeneous spheroid with symmetry axis z');\nh5writeatt(f, '/scatterer/geometry', 'unit', 'nm');\nh5writeatt(f, '/scatterer/geometry', 'shape', 'spheroid')\n\nh5writeatt(f, '/computation', 'description', 'Computation using SMARTIES, a numerically robust EBCM implementation for spheroids');\nh5writeatt(f, '/computation', 'name', 'SMARTIES');\nh5writeatt(f, '/computation', 'method', 'EBCM, Extended Boundary Condition Method');\nh5writeatt(f, '/computation', 'software', 'SMARTIES');\nh5writeatt(f, '/computation', 'version', '1.1');\n\n\nSummary of the file:\n&lt;list&gt;\n├─data: &lt;list&gt;\n│ ├─computation: &lt;list&gt;\n│ │ ├─files: &lt;list&gt;\n│ │ │ └─script: \"% possibly multiple wavelengths↵...\"\n│ │ └─method_parameters: &lt;list&gt;\n│ │   ├─Lmax: 3\n│ │   └─Ntheta: 100\n│ ├─embedding: &lt;list&gt;\n│ │ ├─relative_permeability: 1\n│ │ └─relative_permittivity: 1.7689\n│ ├─modes: &lt;list&gt;\n│ │ ├─l&lt;int [30]&gt;: 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, ...\n│ │ ├─m&lt;int [30]&gt;: -1, -1, 0, 0, 1, 1, -2, -2, -1, -1, ...\n│ │ └─polarization&lt;chr [30]&gt;: \"electric\", \"magnetic\", \"electric\", \"magnetic\", \"electric\", \"magnetic\", \"electric\", \"magnetic\", \"electric\", \"magnetic\", ...\n│ ├─scatterer: &lt;list&gt;\n│ │ ├─geometry: &lt;list&gt;\n│ │ │ ├─radiusxy: 20\n│ │ │ └─radiusz: 40\n│ │ └─material: &lt;list&gt;\n│ │   ├─relative_permeability: 1\n│ │   └─relative_permittivity&lt;cpl [9]&gt;: -11.4+1.181i, -11.4+1.181i, -11.4+1.181i, -11.4+1.181i, -11.4+1.181i, -11.4+1.181i, -11.4+1.181i, -11.4+1.181i, -11.4+1.181i\n│ ├─tmatrix&lt;cpl [8,100]&gt;: 1+1i, 1+1i, 1+1i, 1+1i, 1+1i, 1+1i, 1+1i, 1+1i, 1+1i, 31+31i, ...\n│ └─vacuum_wavelength&lt;dbl [9]&gt;: 400, 450, 500, 550, 600, 650, 700, 750, 800\n└─attributes: &lt;list&gt;\n  ├─root: &lt;list&gt;\n  │ ├─description: \"Computation using SMARTIES, a nu...\"\n  │ ├─keywords: \"gold, spheroid, ebcm, passive, r...\"\n  │ ├─name: \"Au prolate spheroid in water\"\n  │ └─storage_format_version: \"v0.01\"\n  ├─vacuum_wavelength: &lt;list&gt;\n  │ └─unit: \"nm\"\n  ├─computation: &lt;list&gt;\n  │ ├─description: \"Computation using SMARTIES, a nu...\"\n  │ ├─method: \"EBCM, Extended Boundary Conditio...\"\n  │ ├─name: \"SMARTIES\"\n  │ ├─software: \"SMARTIES\"\n  │ └─version: \"1.1\"\n  ├─embedding: &lt;list&gt;\n  │ ├─keywords: \"non-dispersive\"\n  │ └─name: \"H2O, Water\"\n  ├─material: &lt;list&gt;\n  │ ├─keywords: \"dispersive, plasmonic\"\n  │ ├─name: \"Au, Gold\"\n  │ └─reference: \"Au from Raschke et al 10.1103/Ph...\"\n  └─geometry: &lt;list&gt;\n    ├─name: \"homogeneous spheroid with symmet...\"\n    ├─shape: \"spheroid\"\n    └─unit: \"nm\""
  },
  {
    "objectID": "questions.html",
    "href": "questions.html",
    "title": "T-matrix",
    "section": "",
    "text": "One important issue is with electric and magnetic polarization modes, from what I see you order first all electric and then all magnetic, but in the standard now those are alternating. Honestly, I am not fully aware of the advantages, it came from the definition in treams, do not know if there are advantages for you in your way of storing.\n\n\nNo problem\nDoes not seem very intuitive\n\n\nAs I see, in your parameter sweep you plan to save in the same file only wavelength variation, and you do not have any method parameters that change for different wavelengths, so this is all in order.\n\nI think this was decided at the workshop\n\nBut the sweep is somehow inner, not the outer dimension, this can cause problems.\n\nTo clarify\n\nIn computation, now the approach is to have computation/files/ group that includes the source files needed to repeat the computation, and computation/method_parameters group for all the additional parameters that are used by the software.\n\n‘method’,‘EBCM’,… ‘software’,‘SMARTIES’,… ‘version’,‘1.1’,… ‘unit’,‘nm’, … ‘Lmax’, globalN, … ‘Ntheta’, globalnNbTheta, … ‘accuracy’, accuracy\nShould add “script”, currently in comments as\ncomputation/files\nand group the others under\nmethod_parameters\n\nThe name of the material is easier to search in the database if specified as an attribute, so the group itself can be named however you like, but the attribute “name” which has the value “Ag” or “Silver” or better both, would be the place to search for the material name. The reference to permittivity values(as a link to refractiveindex.info etc.) can be in the attribute “reference” of the group, could add also the interpolation method name in the attribute “interpolation” (those are some new aspects that came after discussion in the workshop).\n\nAdd “name” attribute to group as keywords Ag, Silver Add “reference” attribute with DOI Add “interpolation” attribute\n\nSimilarly in geometry, the group name should match the group name in materials/, and have the attribute “shape” to set the name of the shape as you have it, datasets like radius etc are part of the group.\n\n\ngroup name should match the materials group\nradius etc. are part of the group\n\n\nYou also specify shape as dataset with list of letters, this we did not have before, I do not know whether this brings extra advantages.\n\nDon’t know what this means\n\nYou are specifying in the name of the shape that the spheroid is oblate or prolate, which we did not do before, but this is searchable under spheroid so is fine.\n\nOK\n\n“unit” can be added as an attribute to this group, if you do not provide a mesh.\n\nadd “unit” attribute to group"
  },
  {
    "objectID": "export_R.html",
    "href": "export_R.html",
    "title": "Export to ‘.tmat.h5’ format with R",
    "section": "",
    "text": "This document showcases a basic R script to export T-matrices in the .tmat.h5 HDF5 format. For illustration, we start by producing a dummy dataset. This minimal reproducible example file is available for download as a standalone script: export_R.R."
  },
  {
    "objectID": "export_R.html#mockup-input-data",
    "href": "export_R.html#mockup-input-data",
    "title": "Export to ‘.tmat.h5’ format with R",
    "section": "Mockup input data",
    "text": "Mockup input data\nConsistent with the other examples, we generate a 50x30x30 array of dummy data, which repeats 50 times (50 wavelengths) a matrix of 900 entries ranging from \\(1+1i\\) (first element, top left) to \\(900 + 900i\\) (last element, bottom right). Note the expectation of row-major ordering in HDF5. The 3x3 top-left block is\n   1.0000 + 1.0000i   2.0000 + 2.0000i   3.0000 + 3.0000i ...\n  31.0000 +31.0000i  32.0000 +32.0000i  33.0000 +33.0000i ...\n  61.0000 +61.0000i  62.0000 +62.0000i  63.0000 +63.0000i ...\n   ...               ...                ...               ...\nThe rhdf5 package has support for a variety of R objects, including lists which are automatically written as grouped objects in HDF5.\n\nlibrary(rhdf5) # note: dev version to support complex\nlibrary(uuid) # uuid\nlibrary(glue) # string interpolation\nlibrary(purrr) # mapping functions\n\n## dummy data\n\n# possibly multiple wavelengths\nwavelength &lt;- seq(400, 800, by=50)\nNl &lt;- length(wavelength)\n\nLmax &lt;- 3\nqmax &lt;- 2*(Lmax*(Lmax+1)+Lmax) # T-matrix size\n\n# dummy 30x30 matrix values for each wavelength\n# note the byrow due to HDF5 expecting\n# row-major ordering vs R's default column-major\ntdata &lt;- matrix(1:qmax^2 + 1i*(1:qmax^2), qmax, qmax, byrow=TRUE)\n\ntmatrix &lt;- array(NA_complex_, c(Nl,qmax,qmax))\nfor(i in seq_len(Nl))\n  tmatrix[i,,] &lt;- tdata\n\ntmatrix[1,1:3,1:3]\n\nmodes &lt;- list(l = rep(NA_integer_, qmax),\n              m = rep(NA_integer_, qmax),\n              polarization = rep(NA_character_, qmax))\n\ni &lt;- 1\nfor (li in 1:Lmax){\n  for (mi in -li:li){\n    for (si in c(\"electric\", \"magnetic\")){\n      modes$l[i] &lt;- li\n      modes$m[i] &lt;- mi\n      modes$polarization[i] &lt;- si\n      i &lt;-  i+1\n    }\n  }\n}\n\nembedding &lt;- list('relative_permeability' = 1.0, \n                  'relative_permittivity' = 1.33^2)\nscatterer &lt;- list(material = list('relative_permeability' = 1.0, \n                                  'relative_permittivity' =\n                                    rep(-11.4+1.181i,Nl)),\n                  geometry = list('radiusxy' = 20.0, \n                                  'radiusz' = 40.0))\n\ncomputation &lt;- list(method_parameters = list('Lmax' = Lmax, \n                                             'Ntheta' = 100),\n                    files = list(script = paste(readLines('export_R.R'), collapse = \"\\n\")))"
  },
  {
    "objectID": "export_R.html#saving-to-hdf5",
    "href": "export_R.html#saving-to-hdf5",
    "title": "Export to ‘.tmat.h5’ format with R",
    "section": "Saving to HDF5",
    "text": "Saving to HDF5\nThe rhdf5 package provides support for reading/writing HDF5 files into/from R objects. Until my recent request, complex arrays were not supported, but this is now implemented in the dev version of the package.\n\nlibrary(rhdf5) # note: requires dev version to support complex arrays\n# cf https://support.bioconductor.org/p/9156305/#9156408\n# install.packages(\"remotes\")\n# remotes::install_github(\"grimbough/rhdf5@devel\")\n# may need 'crypto' library from openSSL to compile\n# e.g. via brew install openssl on macos\n\nWe can then write the different objects defined above using hwrite. Note the important native = TRUE parameter for the T-matrix data: R stores arrays column-wise, while HDF5 uses row-major ordering. To avoid confusion between different programming languages, we suggest sticking with the native HDF5 convention (native = TRUE ensures that the array is written transposed).\nAttributes don’t seem to have a convenient high-level interface, and unfortunately they need to be written slightly differently for the root level, datasets, and groups.\n\nf &lt;- 'ar.tmat.h5'\n\nunlink(f) # delete previous file if it exists\nh5createFile(f)\nh5closeAll() # in case connections open\n\nh5write(wavelength, file=f, name=\"/vacuum_wavelength\")\n\nh5write(tmatrix, file=f, name=\"/tmatrix\", native=TRUE) # store rowwise\n\nh5write(modes, file=f, name='/modes')\nh5write(embedding, file=f, name=\"/embedding\")\nh5write(scatterer, file=f, name=\"/scatterer\")\nh5write(computation, file=f, name='/computation')\n\n## write attributes\nfid &lt;- H5Fopen(f)\n# root level\nh5writeAttribute(\"Au prolate spheroid in water\", fid, \"name\")\nh5writeAttribute(\"Computation using SMARTIES, a numerically robust EBCM implementation for spheroids\", fid, \"description\")\nh5writeAttribute(\"gold, spheroid, ebcm, passive, reciprocal, czinfinity, mirrorxyz\", fid, \"keywords\")\nh5writeAttribute(\"v0.01\", fid, \"storage_format_version\")\n\n# wavelength\ndid &lt;- H5Dopen(fid, \"vacuum_wavelength\")\nh5writeAttribute(\"nm\", did, \"unit\")\nH5Dclose(did)\n\n# embedding\ngid &lt;- H5Gopen(fid, \"embedding\")\nh5writeAttribute(\"H2O, Water\", gid, \"name\")\nh5writeAttribute(\"non-dispersive\", gid, \"keywords\")\nH5Gclose(gid)\n\n# material\ngid &lt;- H5Gopen(fid, \"scatterer/material\")\nh5writeAttribute(\"Au, Gold\", gid, \"name\")\nh5writeAttribute(\"dispersive, plasmonic\", gid, \"keywords\")\nh5writeAttribute(\"Au from Raschke et al 10.1103/PhysRevB.86.235147\", gid, \"reference\")\nH5Gclose(gid)\n\n# geometry\ngid &lt;- H5Gopen(fid, \"scatterer/geometry\")\nh5writeAttribute(\"nm\", gid, \"unit\")\nh5writeAttribute(\"spheroid\", gid, \"shape\")\nh5writeAttribute(\"homogeneous spheroid with symmetry axis z\", gid, \"name\")\nH5Gclose(gid)\n\n# computation\ngid &lt;- H5Gopen(fid, \"computation\")\nh5writeAttribute(\"EBCM, Extended Boundary Condition Method\", gid, \"method\")\nh5writeAttribute(\"Computation using SMARTIES, a numerically robust EBCM implementation for spheroids\", gid, \"description\")\nh5writeAttribute(\"SMARTIES\", gid, \"software\")\nh5writeAttribute(\"SMARTIES\", gid, \"name\")\nh5writeAttribute(\"1.1\", gid, \"version\")\nH5Gclose(gid)\n\nH5Fclose(fid)\n\n\nSummary of the file:\n&lt;list&gt;\n├─data: &lt;list&gt;\n│ ├─computation: &lt;list&gt;\n│ │ ├─files: &lt;list&gt;\n│ │ │ └─script: \"## ----eval=FALSE---------------...\"\n│ │ └─method_parameters: &lt;list&gt;\n│ │   ├─Lmax: 3\n│ │   └─Ntheta: 100\n│ ├─embedding: &lt;list&gt;\n│ │ ├─relative_permeability: 1\n│ │ └─relative_permittivity: 1.7689\n│ ├─modes: &lt;list&gt;\n│ │ ├─l&lt;int [30]&gt;: 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, ...\n│ │ ├─m&lt;int [30]&gt;: -1, -1, 0, 0, 1, 1, -2, -2, -1, -1, ...\n│ │ └─polarization&lt;chr [30]&gt;: \"electric\", \"magnetic\", \"electric\", \"magnetic\", \"electric\", \"magnetic\", \"electric\", \"magnetic\", \"electric\", \"magnetic\", ...\n│ ├─scatterer: &lt;list&gt;\n│ │ ├─geometry: &lt;list&gt;\n│ │ │ ├─radiusxy: 20\n│ │ │ └─radiusz: 40\n│ │ └─material: &lt;list&gt;\n│ │   ├─relative_permeability: 1\n│ │   └─relative_permittivity&lt;cpl [9]&gt;: -11.4+1.181i, -11.4+1.181i, -11.4+1.181i, -11.4+1.181i, -11.4+1.181i, -11.4+1.181i, -11.4+1.181i, -11.4+1.181i, -11.4+1.181i\n│ ├─tmatrix&lt;cpl [8,100]&gt;: 1+1i, 1+1i, 1+1i, 1+1i, 1+1i, 1+1i, 1+1i, 1+1i, 1+1i, 31+31i, ...\n│ └─vacuum_wavelength&lt;dbl [9]&gt;: 400, 450, 500, 550, 600, 650, 700, 750, 800\n└─attributes: &lt;list&gt;\n  ├─root: &lt;list&gt;\n  │ ├─description: \"Computation using SMARTIES, a nu...\"\n  │ ├─keywords: \"gold, spheroid, ebcm, passive, r...\"\n  │ ├─name: \"Au prolate spheroid in water\"\n  │ └─storage_format_version: \"v0.01\"\n  ├─vacuum_wavelength: &lt;list&gt;\n  │ ├─rhdf5-NA.OK: 1\n  │ └─unit: \"nm\"\n  ├─computation: &lt;list&gt;\n  │ ├─description: \"Computation using SMARTIES, a nu...\"\n  │ ├─method: \"EBCM, Extended Boundary Conditio...\"\n  │ ├─name: \"SMARTIES\"\n  │ ├─software: \"SMARTIES\"\n  │ └─version: \"1.1\"\n  ├─embedding: &lt;list&gt;\n  │ ├─keywords: \"non-dispersive\"\n  │ └─name: \"H2O, Water\"\n  ├─material: &lt;list&gt;\n  │ ├─keywords: \"dispersive, plasmonic\"\n  │ ├─name: \"Au, Gold\"\n  │ └─reference: \"Au from Raschke et al 10.1103/Ph...\"\n  └─geometry: &lt;list&gt;\n    ├─name: \"homogeneous spheroid with symmet...\"\n    ├─shape: \"spheroid\"\n    └─unit: \"nm\""
  },
  {
    "objectID": "export_python.html",
    "href": "export_python.html",
    "title": "Export to ‘.tmat.h5’ format with Python",
    "section": "",
    "text": "This document showcases a basic Matlab script to export T-matrices in the .tmat.h5 HDF5 format. For illustration, we start by producing a dummy dataset. This minimal reproducible example file is available for download as a standalone script: export_python.py."
  },
  {
    "objectID": "export_python.html#mockup-input-data",
    "href": "export_python.html#mockup-input-data",
    "title": "Export to ‘.tmat.h5’ format with Python",
    "section": "Mockup input data",
    "text": "Mockup input data\nConsistent with the other examples, we generate a 50x30x30 array of dummy data, which repeats 50 times (50 wavelengths) a matrix of 900 entries ranging from \\(1+1i\\) (first element, top left) to \\(900 + 900i\\) (last element, bottom right). Note the expectation of row-major ordering in HDF5. The 3x3 top-left block is\n   1.0000 + 1.0000i   2.0000 + 2.0000i   3.0000 + 3.0000i ...\n  31.0000 +31.0000i  32.0000 +32.0000i  33.0000 +33.0000i ...\n  61.0000 +61.0000i  62.0000 +62.0000i  63.0000 +63.0000i ...\n   ...               ...                ...               ...\nThe Python library h5py provides a convenient object-oriented interface to save python objects in the required HDF5 structure, so we don’t need particular care to organise them on the Python side.\n\nimport numpy as np\nimport os, sys\nimport h5py\n#possibly multiple wavelengths\nwavelength  = np.arange(400,850, 50)\nNl = len(wavelength)\nlmax = 3\nqmax = 2*(lmax*(lmax+1)+lmax)\n# dummy 30x30 matrix values repeated for each wavelength\ntdata = np.reshape(np.arange(1,901,1) + 1j*np.arange(1,901,1), (qmax,qmax))\ntmatrix = np.zeros((Nl,qmax,qmax), dtype=\"complex\")\nfor i in range(Nl):\n  tmatrix[i,:,:] = tdata\n\nprint(tmatrix[0,0:3,0:3])\n\nl = np.zeros(qmax)\nm = np.zeros(qmax)\ns = np.array([b'xxxxxxic']*len(l))\ni=0\nfor li in range(1,lmax+1):\n    for mi in range(-li, li+1):\n        for si in [b'electric', b'magnetic']:\n            l[i] = li\n            m[i] = mi\n            s[i] = si\n            i = i+1"
  },
  {
    "objectID": "export_python.html#saving-to-hdf5",
    "href": "export_python.html#saving-to-hdf5",
    "title": "Export to ‘.tmat.h5’ format with Python",
    "section": "Saving to HDF5",
    "text": "Saving to HDF5\nThe Python library h5py provides a convenient interface to generate groups, datasets, and attributes with simple assigments:\n\n# Saving to HDF5\nf = 'ap.tmat.h5';\nwith h5py.File(f, \"w\") as f:\n    f[\"vacuum_wavelength\"] = np.asarray(wavelength)\n    f[\"vacuum_wavelength\"].attrs[\"unit\"] = \"nm\"\n    f[\"tmatrix\"] = tmatrix\n    f['modes/l'] = l\n    f['modes/m'] = m\n    f['modes/polarization'] = s\n    emb = f.create_group(f\"embedding\")\n    emb[\"relative_permittivity\"] = 1.33**2\n    emb[\"relative_permeability\"] = 1.0\n    emb.attrs[\"name\"] = \"H2O, Water\"\n    emb.attrs[\"keywords\"] = \"non-dispersive\"\n    sca_mat = f.create_group(\"scatterer/material\")\n    sca_mat.attrs[\"name\"] = 'Au, Gold'\n    sca_mat.attrs[\"keywords\"] = \"dispersive, plasmonic\"\n    sca_mat.attrs[\"reference\"] = \"Au from Raschke et al 10.1103/PhysRevB.86.235147\"\n    sca_mat[\"relative_permittivity\"] = np.ones(len(wavelength), dtype = complex)*(-11.4+1.181j)\n    sca_mat[\"relative_permeability\"] = 1.0\n    sca_gr = f.create_group(\"scatterer/geometry\")\n    sca_gr[\"radiusxy\"] = 20.0\n    sca_gr[\"radiusz\"] = 40.0\n    sca_gr.attrs['unit'] = 'nm'\n    sca_gr.attrs['shape'] = 'spheroid'\n    sca_gr.attrs['name'] = 'homogeneous spheroid with symmetry axis z'\n    mpar = f.create_group(\"computation/method_parameters\")\n    #f[\"computation/analytical_zeros\"] = analytical_zeros # not needed in this example\n    mpar[\"Lmax\"] = lmax\n    mpar[\"Ntheta\"] = 100\n    f.create_group(\"computation/files\")\n    with open(__file__, \"r\") as scriptfile:\n        f[f\"computation/files/{os.path.basename(__file__)}\"] = scriptfile.read()\n    f[\"computation\"].attrs[\"method\"] = \"EBCM, Extended Boundary Condition Method\" \n    f[\"computation\"].attrs[\"description\"] = \"Computation using SMARTIES, a numerically robust EBCM implementation for spheroids\" \n    f[\"computation\"].attrs[\"software\"] = f\"SMARTIES=1.1, python={sys.version.split()[0]}, h5py={h5py.__version__}\"\n    f[\"computation\"].attrs[\"name\"] = \"SMARTIES\"\n    f[\"computation\"].attrs[\"version\"] = \"1.1\"\n    f.attrs['name'] = 'Au prolate spheroid in water'\n    f.attrs['keywords'] = 'gold, spheroid, ebcm, passive, reciprocal, czinfinity, mirrorxyz'\n    f.attrs['description'] = 'Computation using SMARTIES, a numerically robust EBCM implementation for spheroids'\n    f.attrs['storage_format_version'] = 'v0.01'    \n\n\nSummary of the file:\n&lt;list&gt;\n├─data: &lt;list&gt;\n│ ├─computation: &lt;list&gt;\n│ │ ├─files: &lt;list&gt;\n│ │ │ └─export_python.py: \"import numpy as np↵import os, sy...\"\n│ │ └─method_parameters: &lt;list&gt;\n│ │   ├─Lmax: 3\n│ │   └─Ntheta: 100\n│ ├─embedding: &lt;list&gt;\n│ │ ├─relative_permeability: 1\n│ │ └─relative_permittivity: 1.7689\n│ ├─modes: &lt;list&gt;\n│ │ ├─l&lt;dbl [30]&gt;: 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, ...\n│ │ ├─m&lt;dbl [30]&gt;: -1, -1, 0, 0, 1, 1, -2, -2, -1, -1, ...\n│ │ └─polarization&lt;chr [30]&gt;: \"electric\", \"magnetic\", \"electric\", \"magnetic\", \"electric\", \"magnetic\", \"electric\", \"magnetic\", \"electric\", \"magnetic\", ...\n│ ├─scatterer: &lt;list&gt;\n│ │ ├─geometry: &lt;list&gt;\n│ │ │ ├─radiusxy: 20\n│ │ │ └─radiusz: 40\n│ │ └─material: &lt;list&gt;\n│ │   ├─relative_permeability: 1\n│ │   └─relative_permittivity&lt;cpl [9]&gt;: -11.4+1.181i, -11.4+1.181i, -11.4+1.181i, -11.4+1.181i, -11.4+1.181i, -11.4+1.181i, -11.4+1.181i, -11.4+1.181i, -11.4+1.181i\n│ ├─tmatrix&lt;cpl [8,100]&gt;: 1+1i, 1+1i, 1+1i, 1+1i, 1+1i, 1+1i, 1+1i, 1+1i, 1+1i, 31+31i, ...\n│ └─vacuum_wavelength&lt;int [9]&gt;: 400, 450, 500, 550, 600, 650, 700, 750, 800\n└─attributes: &lt;list&gt;\n  ├─root: &lt;list&gt;\n  │ ├─description: \"Computation using SMARTIES, a nu...\"\n  │ ├─keywords: \"gold, spheroid, ebcm, passive, r...\"\n  │ ├─name: \"Au prolate spheroid in water\"\n  │ └─storage_format_version: \"v0.01\"\n  ├─vacuum_wavelength: &lt;list&gt;\n  │ └─unit: \"nm\"\n  ├─computation: &lt;list&gt;\n  │ ├─description: \"Computation using SMARTIES, a nu...\"\n  │ ├─method: \"EBCM, Extended Boundary Conditio...\"\n  │ ├─name: \"SMARTIES\"\n  │ ├─software: \"SMARTIES=1.1, python=3.11.7, h5p...\"\n  │ └─version: \"1.1\"\n  ├─embedding: &lt;list&gt;\n  │ ├─keywords: \"non-dispersive\"\n  │ └─name: \"H2O, Water\"\n  ├─material: &lt;list&gt;\n  │ ├─keywords: \"dispersive, plasmonic\"\n  │ ├─name: \"Au, Gold\"\n  │ └─reference: \"Au from Raschke et al 10.1103/Ph...\"\n  └─geometry: &lt;list&gt;\n    ├─name: \"homogeneous spheroid with symmet...\"\n    ├─shape: \"spheroid\"\n    └─unit: \"nm\""
  }
]