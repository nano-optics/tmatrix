[
  {
    "objectID": "matlab_export.html",
    "href": "matlab_export.html",
    "title": "Export to ‘.tmat.hdf5’ format with Matlab",
    "section": "",
    "text": "This document describes a few Matlab utility functions to export T-matrices in the standardised HDF5 format. For illustration, we start by producing a dummy dataset. The SMARTIES implementation of EBCM for spheroids uses these tools internally for its HDF5 export."
  },
  {
    "objectID": "matlab_export.html#mockup-input-data",
    "href": "matlab_export.html#mockup-input-data",
    "title": "Export to ‘.tmat.hdf5’ format with Matlab",
    "section": "Mockup input data",
    "text": "Mockup input data\nThe easyh5 library takes care of most of the details for us, when objects are stored in Matlab structures. There are a couple of caveats, illustrated below, such as polarization being handled separately, and attributes being added at a later stage.\n% possibly multiple wavelengths\nwavelength  = (400:50:800)';\nNl = length(wavelength);\n\n% dummy 30x30 matrix values for each wavelength\ntdata = reshape((1:900) + 1i*(1:900), [30,30]);\ntmatrix = repmat(tdata, [1,1,Nl]);\n\n% modes, but note that polarization is handled separately\nmodes = struct('l', 1:30, 'm', 1:30); \npolarization = repmat([\"electric\",\"magnetic\"], 1, 15);\n\n% dummy 'analytical zeros' for e.g. EBCM methods\n[zerosp, zerospp] = ndgrid(1:2:30, 1:2:30);\nzeros  = struct('p', zerosp, 'pp', zerospp);\n\n% materials\nembedding = struct('relative_permeability', 1.0, ...\n                   'relative_permittivity', 1.33^2);\nparticle = struct('relative_permeability', 1.0, ...\n                  'relative_permittivity', -11.4+1.181i);\nmaterialname = 'Au'; \nmaterials = struct('embedding', embedding, materialname, particle);\n\n% geometry\ngeometry = struct('shape', 'spheroid', 'radiusxy', 20.0, 'radiusz', 40.0);\n\n% details about computation, including full script\ncomputation = struct('method','EBCM',...\n    'software','SMARTIES',...\n    'version','1.1',...\n    'Ntheta', 40, ...\n    'accuracy','1e-10', ...\n    'analytical_zeros', zeros, ...\n    'script', fileread('test_dummy.m')); % embed full script as string\n\n% combined (almost all) information into one struct\na = struct('tmatrix', tmatrix, ...\n    'vacuum_wavelength', wavelength, ...\n    'embedding', embedding,...\n    'materials', materials, ...\n    'geometry', geometry, ...\n    'modes', modes, ...\n    'computation', computation, ...\n    'uuid', char(matlab.lang.internal.uuid()));    \n\n[maj,min,rel] = H5.get_libversion();\nhdf5version = sprintf('%d.%d.%d',maj,min,rel);"
  },
  {
    "objectID": "matlab_export.html#saving-to-hdf5",
    "href": "matlab_export.html#saving-to-hdf5",
    "title": "Export to ‘.tmat.hdf5’ format with Matlab",
    "section": "Saving to HDF5",
    "text": "Saving to HDF5\naddpath(genpath('../easyh5/'));\nsaveh5 does most of the work, but we have to write polarization separately as arrays of strings within structs seem to trip easyh5. I did not find how to link the embedding medium from materials to the top level, so it is simply duplicated.\n% save to file\nf = 'am.tmat.h5';\nsaveh5(a, f, 'ComplexFormat', {'r','i'}, 'rootname', '', ...\n       'Compression', 'deflate'); % compression is optional\n\n% write polarization separately\nh5create(f,'/modes/polarization', size(polarization), 'Datatype', 'string')\nh5write(f,'/modes/polarization', polarization)\nAttributes are written in a separate step.\n% write root attributes\nh5writeatt(f, '/', 'name', 'Au prolate spheroid in water');\nh5writeatt(f, '/', 'created_with', 'Matlab easyh5');\nh5writeatt(f, '/','keywords', 'gold, spheroid, ebcm');\nh5writeatt(f, '/', 'storage_format_version', hdf5version);\nh5writeatt(f, '/','description', ...\n    'Computation using SMARTIES, a robust EBCM for spheroids');\n    \n% attributes of specific objects\nh5writeatt(f, '/vacuum_wavelength', 'unit', 'nm');\nh5writeatt(f, '/uuid', 'version', '4');\nh5writeatt(f, '/geometry', 'name', 'prolate spheroid');"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "R_export.html",
    "href": "R_export.html",
    "title": "Export to ‘.tmat.hdf5’ format with R",
    "section": "",
    "text": "This document describes a few R utility functions to export T-matrices in the standardised HDF5 format. For illustration, we start by producing a dummy dataset."
  },
  {
    "objectID": "R_export.html#mockup-input-data",
    "href": "R_export.html#mockup-input-data",
    "title": "Export to ‘.tmat.hdf5’ format with R",
    "section": "Mockup input data",
    "text": "Mockup input data\nThe rhdf5 package has support for a variety of R objects, including lists which are automatically written as grouped objects in HDF5.\n# possibly multiple wavelengths\nwavelength &lt;- seq(400, 800, by=50)\nNl &lt;- length(wavelength)\n\n# dummy 30x30 matrix values for each wavelength\ntmatrix &lt;- array(1:900 + 1i*(1:900), c(30,30,Nl))\n\nmodes &lt;- list('l' = 1:30,'m' = 1:30,\n              'polarization' =  rep(c('electric','magnetic'),15))\n\n# dummy 'analytical zeros' for e.g. EBCM methods\nzeros &lt;- expand.grid(p=seq(1,30,by=2), pp = seq(1,30,by=2))\n\nmaterials &lt;- list('embedding' = list('relative_permeability' = 1.0,\n                                     'relative_permittivity' = 1.33^2), \n                  'Au' = list('relative_permeability' = 1.0,\n                              'relative_permittivity' = -11.4+1.181i))\n\ngeometry &lt;- list('shape' = 'spheroid','radiusxy' = 20.0, 'radiusz' = 40.0)\n\n# details about computation, including full script\nscript &lt;-  glue::glue_collapse(readLines('test-dummy.R'), sep = \"\\n\")\ncomputation &lt;- list('method' ='EBCM',\n                    'software' = 'SMARTIES',\n                    'version' = '1.1',\n                    'Ntheta' = 40, \n                    'accuracy' = 1e-10, \n                    'analytical_zeros' = zeros,\n                    'script' = script)\n\nuuid &lt;- uuid::UUIDgenerate()\nhdf5version &lt;- glue::glue_collapse(H5get_libversion(),\".\")"
  },
  {
    "objectID": "R_export.html#saving-to-hdf5",
    "href": "R_export.html#saving-to-hdf5",
    "title": "Export to ‘.tmat.hdf5’ format with R",
    "section": "Saving to HDF5",
    "text": "Saving to HDF5\nThe rhdf5 package provides support for reading/writing HDF5 files into/from R objects. Until my recent request, complex arrays were not supported, but this is now implemented in the dev version of the package. The glue and purrr packages are only used for convenience, and can easily be replaced with base functions.\nlibrary(rhdf5) # note: requires dev version to support complex arrays\n# cf https://support.bioconductor.org/p/9156305/#9156408\n# install.packages(\"remotes\")\n# remotes::install_github(\"grimbough/rhdf5@devel\")\n# may need 'crypto' library from openSSL to compile\n# e.g. via brew install openssl on macos\n\nlibrary(uuid) # uuid\nlibrary(glue) # string interpolation\nlibrary(purrr) # mapping functions\n## create file\nf &lt;- 'ar.tmat.h5'\nunlink(f)\nh5createFile(f)\nh5closeAll()\nWe can then write the different objects defined above using hwrite. Note the important native = TRUE parameter for the T-matrix data: R stores arrays column-wise, while HDF5 uses row-major ordering. To avoid confusion between different programming languages, we suggest sticking with the native HDF5 convention (native = TRUE ensures that the array is written transposed).\n## write file\nh5write(tmatrix, file=f, name=\"/tmatrix\", native=TRUE) # store rowwise\n# Using native = TRUE increases HDF5 file portability between programming languages\nh5write(modes, file=f, name='/modes')\nh5write(wavelength, file=f, name=\"/vacuum_wavelength\")\nh5write(embedding, file=f, name=\"/embedding\")\nh5write(materials, file=f, name=\"/materials\")\nh5write(geometry, file=f, name=\"/geometry\")\nh5write(computation, file=f, name='/computation')\nh5write(uuid, file=f, name='/uuid')\nAttributes are written in a separate step, and a convenience wrapper function write_attributes(object, names, attributes, type) is used to simplify the interface.\n## open file\nfid &lt;- H5Fopen(f)\n## root attributes\nwrite_attributes(\"/\",\n                 names = list(\"name\",\n                              \"created_with\",\n                              \"storage_format_version\",\n                              \"description\", \n                              'keywords'), \n                 attributes = list(\"Au prolate spheroid in water\",\n                                   \"rhdf5\",\n                                   hdf5version,\n                    \"Computation using SMARTIES, a robust EBCM for spheroids\", 'gold, spheroid, ebcm'), \n                 type = \"root\")\n\n## object attributes\nwrite_attributes(\"tmatrix\",\n                 names=c(\"units\",\"created_with\"),\n                 attributes = c(\"nm\",\"rhdf5\"), \n                 type = \"dataset\")\n\nwrite_attributes(\"vacuum_wavelength\",\n                 names=c(\"unit\"), \n                 attributes = c(\"nm\"), \n                 type = \"dataset\")\n\nwrite_attributes(\"uuid\",\n                 names=c(\"version\"), \n                 attributes = c(\"4\"), \n                 type = \"dataset\")\n\nwrite_attributes(\"geometry\",\n                 names=c(\"name\"), \n                 attributes = c(\"prolate spheroid\"), \n                 type = \"group\")\n## close file\nH5Fclose(fid)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": ".",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "julia_export.html",
    "href": "julia_export.html",
    "title": "Export to ‘.tmat.hdf5’ format with Julia",
    "section": "",
    "text": "This document describes the process of exporting T-matrices in the standardised HDF5 format in Julia. For illustration, we start by producing a dummy dataset."
  },
  {
    "objectID": "julia_export.html#mockup-input-data",
    "href": "julia_export.html#mockup-input-data",
    "title": "Export to ‘.tmat.hdf5’ format with Julia",
    "section": "Mockup input data",
    "text": "Mockup input data\nFor convenience, we store compound objects as Dictionaries, which will then be mapped into HDF5 groups during export.\nusing Pkg, UUIDs\n\n# possibly multiple wavelengths\nwavelength  = collect(400:50:800)\nNl = length(wavelength)\n\n# dummy 30x30 matrix values for each wavelength\ntmatrix = reshape(repeat(collect(1:900.0) + collect(1:900)*1im, Nl), \n                  (30,30,Nl))\n\nmodes = Dict(\"l\" =&gt; collect(1:30), \n             \"m\" =&gt; collect(1:30), \n             \"polarisation\" =&gt; repeat([\"electric\",\"magnetic\"],  15))\n             \n# dummy 'analytical zeros' for e.g. EBCM methods\nazeros = collect(Iterators.product(1:2:30, 1:2:30))\nanalytical_zeros = Dict(\"p\" =&gt; [z[1] for z in azeros[:]],\n                        \"pp\" =&gt; [z[2] for z in azeros[:]])\n                                               \nmaterials = Dict(\"embedding\" =&gt; Dict(\"relative_permeability\" =&gt; 1.0,\n                                     \"relative_permittivity\" =&gt; 1.33^2), \n                  \"Au\" =&gt; Dict(\"relative_permeability\" =&gt; 1.0,\n                              \"relative_permittivity\" =&gt; -11.4+1.181im))\n\ngeometry = Dict(\"shape\" =&gt; \"spheroid\",\n                \"radiusxy\" =&gt; 20.0,\n                \"radiusz\" =&gt; 40.0)\n\n# details about computation, including full script\ncomputation = Dict(\"method\" =&gt;\"EBCM\",\n                    \"software\" =&gt; \"SMARTIES\",\n                    \"version\" =&gt; \"1.1\",\n                    \"Ntheta\" =&gt; 40, \n                    \"accuracy\" =&gt; 1e-10, \n                    \"analytical_zeros\" =&gt; analytical_zeros,\n                    \"script\" =&gt; read(\"test_dummy.jl\", String))\n\nuuid = string(UUIDs.uuid4())\n\npkgs = Pkg.Operations.Context().env.manifest\nhdf5version = string(pkgs[findfirst(v-&gt;v.name == \"HDF5\", pkgs)].version)"
  },
  {
    "objectID": "julia_export.html#saving-to-hdf5",
    "href": "julia_export.html#saving-to-hdf5",
    "title": "Export to ‘.tmat.hdf5’ format with Julia",
    "section": "Saving to HDF5",
    "text": "Saving to HDF5\nThe HDF5.jl library provides all the tools required, and a relatively high-level interface. Unlike R and Matlab, there does not seem to be a built-in high-level way to store Dict objects, so I wrote the following wrapper.\nfunction write_dict(groupname, dict::Dict)\n    g = create_group(fid, groupname) \n    for (key, value) in dict\n        keyname = groupname * \"/\" * key\n        if typeof(value) &lt;: Dict # nested, recurse\n            write_dict(keyname, value)\n        else\n            write(fid, keyname, value)\n        end\n    end\nend\nComplex arrays are stored with r and i fields as usual. Note that Julia has column-major ordering, unlike HDF5, and we therefore explicitly transpose the matrix before saving it, to avoid confusion if the data are to be read in another language. I did not find how to link the embedding medium from materials to the top level, so it is simply duplicated.\nusing HDF5\n\nf = \"aj.tmat.h5\"\nfid = h5open(f, \"w\")\n\n# write top-level datasets\nfid[\"vacuum_wavelength\"] = wavelength\nfid[\"tmatrix\"] = tmatrix\nfid[\"uuid\"] = uuid\n\n# write groups (some nested)\nwrite_dict(\"embedding\", embedding)\nwrite_dict(\"materials\", materials)\nwrite_dict(\"geometry\", geometry)\nwrite_dict(\"modes\", modes)\nwrite_dict(\"computation\", computation)\n\n# write attributes\nattributes(fid)[\"name\"] = \"Au prolate spheroid in water\"\nattributes(fid)[\"created_with\"] = \"HDF5.jl\"\nattributes(fid)[\"storage_format_version\"] = hdf5version\nattributes(fid)[\"description\"] = \"Computation using SMARTIES, a numerically robust EBCM implementation for spheroids\"\nattributes(fid)[\"keywords\"] = \"gold, spheroid, ebcm\"\nattributes(fid[\"vacuum_wavelength\"])[\"unit\"] = \"nm\"\nattributes(fid[\"uuid\"])[\"version\"] = \"4\"\nattributes(fid[\"geometry\"])[\"name\"] = \"prolate spheroid\"\n\nclose(fid)\n% save to file\nf = 'am.tmat.h5';\nsaveh5(a, f, 'ComplexFormat', {'r','i'}, 'rootname', '', ...\n       'Compression', 'deflate'); % compression is optional\n\n% write polarization separately\nh5create(f,'/modes/polarization', size(polarization), 'Datatype', 'string')\nh5write(f,'/modes/polarization', polarization)\nAttributes are written in a separate step.\n% write root attributes\nh5writeatt(f, '/', 'name', 'Au prolate spheroid in water');\nh5writeatt(f, '/', 'created_with', 'Matlab easyh5');\nh5writeatt(f, '/','keywords', 'gold, spheroid, ebcm');\n[maj,min,rel] = H5.get_libversion();\nh5writeatt(f, '/', 'storage_format_version', sprintf('%d.%d.%d',maj,min,rel));\nh5writeatt(f, '/','description', ...\n    'Computation using SMARTIES, a robust EBCM for spheroids');\n    \n% attributes of specific objects\nh5writeatt(f, '/vacuum_wavelength', 'unit', 'nm');\nh5writeatt(f, '/uuid', 'version', '4');\nh5writeatt(f, '/geometry', 'name', 'prolate spheroid');"
  }
]