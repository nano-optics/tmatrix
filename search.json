[
  {
    "objectID": "display.html",
    "href": "display.html",
    "title": "Displaying T-matrices with R",
    "section": "",
    "text": "R utility functions used below.\nThe following R code produces a visual heatmap of a T-matrix with a standard 2x2 block matrix layout and indexing conventions.\nExample data in long format:\n\nd &lt;- read.table('data/tmat_Au20x40_Nmax3.tmat')\nnames(d) &lt;- c('s','sp','l','lp','m','mp','Tr','Ti')\nd &lt;- tmatrix_combinedindex(d)\n\nCustom visualisation:\n\nlmax &lt;- max(d$l)\nbreaks &lt;- tmatrix_breaks(lmax)\n\np &lt;- ggplot(d, aes(q, qp, fill= log10(Mod(Tr + 1i*Ti)))) +\n  geom_raster() +\n  coord_equal() +\n  scale_fill_viridis_c(option = 'A', direction = -1) +\n  annotate('segment',x=0.5,xend=max(breaks$breaks)+0.5,y=max(breaks$breaks)/2+0.5,\n           yend=max(breaks$breaks)/2+0.5,colour='white')+\n  annotate('segment',y=0.5,yend=max(breaks$breaks)+0.5,x=max(breaks$breaks)/2+0.5,\n           xend=max(breaks$breaks)/2+0.5,colour='white')+\n  scale_y_reverse(expand=c(0,0), breaks= breaks$breaks+0.5, minor_breaks=breaks$minor_breaks+0.5, labels=breaks$labels) +\n  scale_x_continuous(expand=c(0,0), breaks= breaks$breaks+0.5, minor_breaks=breaks$minor_breaks+0.5, labels=breaks$labels) +\n  theme_minimal() +\n  theme(panel.grid = element_line(colour = 'white'), \n        panel.background = element_rect(fill='grey90',colour='white'),\n        panel.border = element_rect(colour='black',fill=NA,linewidth = 0.2),\n        axis.text.x = element_text(hjust=1),\n        axis.text.y = element_text(vjust=0)) +\n  labs(x=\"p\",y=\"p'\",fill=expression(log~\"|T|\"))\n\nprint(p)\n\n\n\n\n\n\n\n\nNote that ggplot2 makes it easy to plot multiple facets to compare different datasets,\n\n# combine data with another T-matrix from Treams\nd2 &lt;- read_treams('data/SPH-DE~4.H5')\nm &lt;- rbind(mutate(d, type = \"SMARTIES\"),\n           mutate(d2[,names(d)], type = \"Treams\"))\n\n# update the plot with these data, and facet by type\np %+% m + facet_wrap(~type)"
  },
  {
    "objectID": "purl.html",
    "href": "purl.html",
    "title": "testpurl",
    "section": "",
    "text": "1 + 1\n\n\nplot(1,1)"
  },
  {
    "objectID": "smarties_batch.html",
    "href": "smarties_batch.html",
    "title": "Calculating many SMARTIES T-matrices",
    "section": "",
    "text": "Below is an example script to run many SMARTIES simulations and export the T-matrices in HDF5. The script is available as standalone script smarties_batch.R.\n\nlibrary(glue)\nlibrary(dplyr)\nlibrary(purrr)\n\n# read in the template\ntemplate &lt;- glue_collapse(readLines('smarties/_template.m'), sep = \"\\n\")\n\nparameters &lt;- expand.grid(a = seq(10, 100, by=5), c = seq(10, 100, by=5),\n                          material = c(\"Au\", \"Ag\", \"Si\"), \n                          medium = c(\"vacuum\", \"water\")) |&gt; \n  filter(a != c) |&gt; # use Mie for this\n  mutate(shape = ifelse(a &gt; c, \"oblate\", \"prolate\"),\n         n = ifelse(medium == \"water\", 1.33, 1.0),\n         source = case_when(material == \"Au\" ~ \"Raschke et al 10.1103/PhysRevB.86.235147\", \n                            material == \"Ag\" ~ \"Raschke et al 10.1103/PhysRevB.91.235137\",\n                            material == \"Si\" ~ \"Aspnes et al 10.1103/PhysRevB.27.985\",\n                            .default = \"Unknown material!\"))\n\nparameters$step &lt;- 1\nnrow(parameters)\n\n[1] 2052\n\n\nFor initial testing, we’ll run much fewer combinations\n\nparameters &lt;- expand.grid(a = seq(20, 50, by=10), c = seq(20, 50, by=10),\n                          material = c(\"Au\", \"Ag\"), \n                          medium = c(\"water\")) |&gt; \n  filter(a != c) |&gt; # use Mie for this\n  mutate(shape = ifelse(a &gt; c, \"oblate\", \"prolate\"),\n         n = ifelse(medium == \"water\", 1.33, 1.0),\n         source = case_when(material == \"Au\" ~ \"Raschke et al 10.1103/PhysRevB.86.235147\", \n                            material == \"Ag\" ~ \"Raschke et al 10.1103/PhysRevB.91.235137\",\n                            material == \"Si\" ~ \"Aspnes et al 10.1103/PhysRevB.27.985\",\n                            .default = \"Unknown material!\"))\nparameters$step &lt;- 5\n\nEven with these restricted options, there’s already 24 combinations.\n\n\n\n\n\n\n\n\na\nc\nshape\nmaterial\nmedium\n\n\n\n\n30\n20\noblate\nAu\nwater\n\n\n40\n20\noblate\nAu\nwater\n\n\n50\n20\noblate\nAu\nwater\n\n\n20\n30\nprolate\nAu\nwater\n\n\n40\n30\noblate\nAu\nwater\n\n\n50\n30\noblate\nAu\nwater\n\n\n20\n40\nprolate\nAu\nwater\n\n\n30\n40\nprolate\nAu\nwater\n\n\n50\n40\noblate\nAu\nwater\n\n\n20\n50\nprolate\nAu\nwater\n\n\n30\n50\nprolate\nAu\nwater\n\n\n40\n50\nprolate\nAu\nwater\n\n\n30\n20\noblate\nAg\nwater\n\n\n40\n20\noblate\nAg\nwater\n\n\n50\n20\noblate\nAg\nwater\n\n\n20\n30\nprolate\nAg\nwater\n\n\n40\n30\noblate\nAg\nwater\n\n\n50\n30\noblate\nAg\nwater\n\n\n20\n40\nprolate\nAg\nwater\n\n\n30\n40\nprolate\nAg\nwater\n\n\n50\n40\noblate\nAg\nwater\n\n\n20\n50\nprolate\nAg\nwater\n\n\n30\n50\nprolate\nAg\nwater\n\n\n40\n50\nprolate\nAg\nwater\n\n\n\n\n\n\n\nWe use the “glue” package to inject the parameters into the template, where the variables are indicated between braces {}. The process loops over each parameter combination and outputs a new file with corresponding filename.\n\nwrite_script &lt;- function(a, c, material, medium, shape, n, step, source){\n script &lt;- glue(template)   \n cat(script, file = glue('smarties/run_{material}_{medium}_{a}_{c}.m'))\n cat(glue(\"run_{material}_{medium}_{a}_{c}\\n\\n\"), \n     file = \"smarties/batch.m\", append = TRUE)\n}\n cat(\"%% Running all the files below\\n\",file = \"smarties/batch.m\", append = FALSE)\npwalk(rowwise(parameters), write_script)\n\nRunning the batch script in Matlab results in 24 output T-matrix files of size between 4 and 6Mb each, with the 5nm step defined above. The value of Lmax needed for \\(10^{-10}\\) accuracy in \\(\\langle\\sigma_\\text{ext}\\rangle\\) appears to be around 11."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "R_export.html",
    "href": "R_export.html",
    "title": "Export to ‘.tmat.hdf5’ format with R",
    "section": "",
    "text": "This document describes a few steps to export T-matrices in the standardised HDF5 format using R. For illustration, we start by producing a dummy dataset. A minimal reproducible example file is available for download: test_dummy.R."
  },
  {
    "objectID": "R_export.html#mockup-input-data",
    "href": "R_export.html#mockup-input-data",
    "title": "Export to ‘.tmat.hdf5’ format with R",
    "section": "Mockup input data",
    "text": "Mockup input data\nThe rhdf5 package has support for a variety of R objects, including lists which are automatically written as grouped objects in HDF5.\n# possibly multiple wavelengths\nwavelength &lt;- seq(400, 800, by=50)\nNl &lt;- length(wavelength)\n\n# dummy 30x30 matrix values for each wavelength\ntmatrix &lt;- array(1:900 + 1i*(1:900), c(30,30,Nl))\n\nmodes &lt;- list('l' = 1:30,'m' = 1:30,\n              'polarization' =  rep(c('electric','magnetic'),15))\n\n# dummy 'analytical zeros' for e.g. EBCM methods\nzeros &lt;- expand.grid(q=seq(1,30,by=2), qp = seq(1,30,by=2))\n\nembedding &lt;- list('relative_permeability' = 1.0, 'relative_permittivity' = 1.33^2)\nmaterials &lt;- list('embedding' = embedding, \n                  'Au' = list('relative_permeability' = 1.0, \n                              'relative_permittivity' = rep(-11.4+1.181i,Nl)))\n\ngeometry &lt;- list('shape' = 'spheroid','radiusxy' = 20.0, 'radiusz' = 40.0)\n\n# details about computation, including full script\nscript &lt;-  glue::glue_collapse(readLines('test_dummy.R'), sep = \"\\n\")\ncomputation &lt;- list('method' ='EBCM',\n                    'software' = 'SMARTIES',\n                    'version' = '1.1',\n                    'Ntheta' = 40, \n                    'accuracy' = 1e-10, \n                    'analytical_zeros' = zeros,\n                    'script' = script)\n\nuuid &lt;- uuid::UUIDgenerate()\nhdf5version &lt;- glue::glue_collapse(H5get_libversion(),\".\")"
  },
  {
    "objectID": "R_export.html#saving-to-hdf5",
    "href": "R_export.html#saving-to-hdf5",
    "title": "Export to ‘.tmat.hdf5’ format with R",
    "section": "Saving to HDF5",
    "text": "Saving to HDF5\nThe rhdf5 package provides support for reading/writing HDF5 files into/from R objects. Until my recent request, complex arrays were not supported, but this is now implemented in the dev version of the package. The glue and purrr packages are only used for convenience, and can easily be replaced with base functions.\nlibrary(rhdf5) # note: requires dev version to support complex arrays\n# cf https://support.bioconductor.org/p/9156305/#9156408\n# install.packages(\"remotes\")\n# remotes::install_github(\"grimbough/rhdf5@devel\")\n# may need 'crypto' library from openSSL to compile\n# e.g. via brew install openssl on macos\n\nlibrary(uuid) # uuid\nlibrary(glue) # string interpolation\nlibrary(purrr) # mapping functions\n## create file\nf &lt;- 'ar.tmat.h5'\nunlink(f)\nh5createFile(f)\nh5closeAll()\nWe can then write the different objects defined above using hwrite. Note the important native = TRUE parameter for the T-matrix data: R stores arrays column-wise, while HDF5 uses row-major ordering. To avoid confusion between different programming languages, we suggest sticking with the native HDF5 convention (native = TRUE ensures that the array is written transposed).\n## write file\nh5write(tmatrix, file=f, name=\"/tmatrix\", native=TRUE) # store rowwise\n# Using native = TRUE increases HDF5 file portability between programming languages\nh5write(modes, file=f, name='/modes')\nh5write(wavelength, file=f, name=\"/vacuum_wavelength\")\nh5write(embedding, file=f, name=\"/embedding\")\nh5write(materials, file=f, name=\"/materials\")\nh5write(geometry, file=f, name=\"/geometry\")\nh5write(computation, file=f, name='/computation')\nh5write(uuid, file=f, name='/uuid')\nAttributes are written in a separate step, and a convenience wrapper function write_attributes(object, names, attributes, type) is used to simplify the interface. This function is available in the file _fun.R.\n## open file\nfid &lt;- H5Fopen(f)\n## root attributes\nwrite_attributes(\"/\",\n                 names = list(\"name\",\n                              \"created_with\",\n                              \"storage_format_version\",\n                              \"description\", \n                              'keywords'), \n                 attributes = list(\"Au prolate spheroid in water\",\n                                   \"rhdf5\",\n                                   hdf5version,\n                    \"Computation using SMARTIES, a robust EBCM for spheroids\", 'gold, spheroid, ebcm'), \n                 type = \"root\")\n\n## object attributes\nwrite_attributes(\"tmatrix\",\n                 names=c(\"units\",\"created_with\"),\n                 attributes = c(\"nm\",\"rhdf5\"), \n                 type = \"dataset\")\n\nwrite_attributes(\"vacuum_wavelength\",\n                 names=c(\"unit\"), \n                 attributes = c(\"nm\"), \n                 type = \"dataset\")\n\nwrite_attributes(\"uuid\",\n                 names=c(\"version\"), \n                 attributes = c(\"4\"), \n                 type = \"dataset\")\n\nwrite_attributes(\"geometry\",\n                 names=c(\"name\"), \n                 attributes = c(\"prolate spheroid\"), \n                 type = \"group\")\n## close file\nH5Fclose(fid)"
  },
  {
    "objectID": "smarties.html",
    "href": "smarties.html",
    "title": "Exporting SMARTIES T-matrices",
    "section": "",
    "text": "Below is an example script to run many SMARTIES simulations and export the T-matrices in HDF5. The script is available as standalone script smarties.m.\nSMARTIES provides some functions to estimate the maximum multipolar order and number of quadrature points required to reach a desired accuracy. We choose here to fix the relative accuracy to \\(10^{-10}\\) for the orientation-averaged extinction cross-section, which results in higher \\(lmax\\) values for larger and/or more elongated spheroids.\n\npath(pathdef); % clear previous path changes\naddpath(genpath('~/Documents/nano-optics/smarties/'));\naddpath(genpath('~/Documents/nano-optics/easyh5/'));\nclearvars;\n\n%% example\n\n% requested precision (OA Cext)\naccuracy = 1e-10;\n\n% prolate Au spheroid in water\n% semi-axes a=b=20nm, c=40nm\nwavelength = 600:50:800; wavelength = wavelength(:); \nNl = length(wavelength);\nepsilon=epsAu(wavelength);\nmedium=1.33;\n\n% constant simulation parameters\nstParams.a=20;\nstParams.c=40;\n\n% internal options\nstOptions.bGetR = false;\nstOptions.Delta = 0;\nstOptions.NB = 0; % NB will be estimated automatically\nstOptions.bGetSymmetricT = false;\nstOptions.bOutput = false; % verbosity\n\nWe first figure out the maximum convergence parameters required\n\n\nglobalN = 1;\nglobalnNbTheta = 1;\n\nfor i=1:Nl\n    stParams.k1=medium*2*pi/wavelength(i);\n    stParams.s=sqrt(epsilon(i)) / medium;\n    % Estimated convergence params\n    [N, nNbTheta] = sphEstimateNandNT(stParams, stOptions, accuracy);\n    stParams.N=N; stParams.nNbTheta=nNbTheta;\n    % Increase params to test accuracy\n    stParams2=stParams;\n    stParams2.N=stParams2.N+5;\n    stParams2.nNbTheta=stParams2.nNbTheta+5;\n\n    [stCoa, stT] = slvForT(stParams,stOptions);\n    [stCoa2, stT2] = slvForT(stParams2,stOptions);\n\n    if(stOptions.bOutput)\n        fprintf('Convergence testing... lambda = %.5g\\n', wavelength(i));\n        fprintf('&lt;Cext&gt; = %.10g,   relative error: %.2g\\n', stCoa.Cext, abs(stCoa.Cext./stCoa2.Cext-1));\n        fprintf('&lt;Csca&gt; = %.10g,   relative error: %.2g\\n', stCoa.Csca, abs(stCoa.Csca./stCoa2.Csca-1));\n        fprintf('&lt;Cabs&gt; = %.10g,   relative error: %.2g\\n', stCoa.Cabs, abs(stCoa.Cabs./stCoa2.Cabs-1));\n    end\n\n    if(abs(stCoa.Cext./stCoa2.Cext-1) &gt; 1.1*accuracy)\n        warning('requested precision was not achieved')\n    end\n\n    globalN = max(globalN, stParams.N);\n    globalnNbTheta = max(globalnNbTheta, stParams.nNbTheta);\nend\n\nNext, we redo the calculations for all wavelengths with these fixed parameters.\n\n\n% allocate 3D array for all results\nqmax = 2*(globalN*(globalN + 1) + globalN );\ntmatrix = zeros(qmax, qmax, Nl);\n\nfor i=1:Nl\n    stParams.k1=medium*2*pi/wavelength(i);\n    stParams.s=sqrt(epsilon(i)) / medium;\n\n    stParams.N=globalN; stParams.nNbTheta=globalnNbTheta;\n\n    [stCoa, stT] = slvForT(stParams,stOptions);\n\n    [T, q, qp] = exportTmatrix( stT, true, [], [] );\n    ind = sub2ind(size(tmatrix),q,qp,q*0+i);\n    tmatrix(ind) =  T(:,7) + 1i*T(:,8);\n\nend\n\nFinally, we export the data into HDF5.\n\nvecq = 1:qmax;\nvecs = [repmat(1,1, qmax/2), repmat(2,1, qmax/2)];\nvecp = vecq - (vecs - 1) * qmax/2;\nvecl = floor(sqrt(vecp));\nvecm = vecp - vecl.*(vecl + 1);\n\n\npolars = [\"electric\",\"magnetic\"];\nmodes = struct('l', int16(vecl),'m', int16(vecm), 'polarization', polars(vecs));\n\nepsilon = struct('embedding', medium^2, 'Au', epsilon);\n\ngeometry = struct('description',  'prolate spheroid', ...\n    'shape', 'spheroid','radiusxy', stParams.a, 'radiusz', stParams.c);\n\ncomputation = struct('method','EBCM',...\n    'software','SMARTIES',...\n    'version','1.1',...\n    'unit','nm', ...\n    'Lmax', globalN, ...\n    'Ntheta', globalnNbTheta, ...\n    'accuracy', accuracy);\n\ncomments = struct('name', 'Au prolate spheroid in water',...\n    'description', 'Computation using SMARTIES, a numerically robust EBCM implementation for spheroids',...\n    'sources', 'Au from Raschke et al 10.1103/PhysRevB.86.235147',...\n    'keywords', 'gold, spheroid, ebcm', ...\n    'script', [mfilename '.m']);\n\n\n[f, uuid] = tmatrix_hdf5('smarties_spectrum.tmat.h5', tmatrix, modes, wavelength, epsilon, geometry, computation, comments)\n\nOutput file: smarties_spectrum.tmat.h5"
  },
  {
    "objectID": "conversion.html",
    "href": "conversion.html",
    "title": "Conversion long/wide",
    "section": "",
    "text": "R utility functions used below."
  },
  {
    "objectID": "conversion.html#reading-long-format-t-matrix-files",
    "href": "conversion.html#reading-long-format-t-matrix-files",
    "title": "Conversion long/wide",
    "section": "Reading long-format T-matrix files",
    "text": "Reading long-format T-matrix files\nSome programs output T-matrices in long format, similar to the example below:\n\nd &lt;- read.table('data/tmat_Au20x40_Nmax3.tmat')\nnames(d) &lt;- c('s','sp','l','lp','m','mp','Tr','Ti')\nhead(d)\n\n  s sp l lp  m mp            Tr            Ti\n1 1  1 1  1 -1 -1 -6.049214e-05 -4.266526e-04\n2 1  1 1  1  0  0 -3.331557e-05 -3.932179e-04\n3 1  1 1  1  1  1 -6.049214e-05 -4.266526e-04\n4 1  1 1  3 -1 -1 -2.374705e-07 -1.995117e-06\n5 1  1 1  3  0  0 -1.110299e-07 -1.278537e-06\n6 1  1 1  3  1  1 -2.374705e-07 -1.995117e-06\n\n\nNote that one advantage of this format is that only non-zero entries need to be provided, similar to a sparse matrix definition. With such data, it can be useful to add combined indices \\(p\\) (blocks) and \\(q\\) (full matrix), as illustrated below:\n\nd &lt;- tmatrix_combinedindex(d)\nhead(d)\n\n  s sp l lp  m mp            Tr            Ti p pp q qp\n1 1  1 1  1 -1 -1 -6.049214e-05 -4.266526e-04 1  1 1  1\n2 1  1 1  1  0  0 -3.331557e-05 -3.932179e-04 2  2 2  2\n3 1  1 1  1  1  1 -6.049214e-05 -4.266526e-04 3  3 3  3\n4 1  1 1  3 -1 -1 -2.374705e-07 -1.995117e-06 1 11 1 11\n5 1  1 1  3  0  0 -1.110299e-07 -1.278537e-06 2 12 2 12\n6 1  1 1  3  1  1 -2.374705e-07 -1.995117e-06 3 13 3 13"
  },
  {
    "objectID": "conversion.html#reading-wide-data-and-converting-to-long-format",
    "href": "conversion.html#reading-wide-data-and-converting-to-long-format",
    "title": "Conversion long/wide",
    "section": "Reading wide data and converting to long format",
    "text": "Reading wide data and converting to long format\nThe function read_treams() reads a standard HDF5-stored T-matrix and returns it in long format, including the computation’s method_parameters fields.\n\nd &lt;- read_treams('data/SPH-DE~4.H5')\nhead(d)\n\n  s sp l lp  m mp            Tr            Ti          mod p pp q qp domain_x\n1 1  1 1  1 -1 -1 -5.907953e-05 -4.253829e-04 4.294659e-04 1  1 1  1      633\n2 1  1 1  1  0  0 -3.230918e-05 -3.810847e-04 3.824519e-04 2  2 2  2      633\n3 1  1 1  1  1  1 -5.907953e-05 -4.253829e-04 4.294659e-04 3  3 3  3      633\n4 1  1 1  2 -1 -1  5.408062e-10 -4.834050e-09 4.864207e-09 1  5 1  5      633\n5 1  1 1  2  0  0 -1.995470e-11 -3.206499e-09 3.206561e-09 2  6 2  6      633\n6 1  1 1  2  1  1  5.408062e-10 -4.834050e-09 4.864207e-09 3  7 3  7      633\n  domain_y domain_z fem_degree max_refinements maximumSideLength\n1      633      633          2               1                13\n2      633      633          2               1                13\n3      633      633          2               1                13\n4      633      633          2               1                13\n5      633      633          2               1                13\n6      633      633          2               1                13\n  maximumSideLengthDomain precision\n1                      13     1e-05\n2                      13     1e-05\n3                      13     1e-05\n4                      13     1e-05\n5                      13     1e-05\n6                      13     1e-05"
  },
  {
    "objectID": "conversion.html#convert-to-wide",
    "href": "conversion.html#convert-to-wide",
    "title": "Conversion long/wide",
    "section": "Convert to wide",
    "text": "Convert to wide\nIf we wish to convert to a true matrix representation, the following function adds all the missing zeros and places the entries at the combined indices \\((q,q')\\),\n\nw &lt;- tmatrix_wide(d)\n\n30 x 30 matrix of characters: \n\n                   [,1]              [,2] ...             [,30]\n[1,]  -5.9e-05-4.3e-04i  0.0e+00+0.0e+00i ...  0.0e+00+0.0e+00i\n[2,]   0.0e+00+0.0e+00i -3.2e-05-3.8e-04i ...  0.0e+00+0.0e+00i\n[3,]   0.0e+00+0.0e+00i  0.0e+00+0.0e+00i ...  0.0e+00+0.0e+00i\n...                 ...               ... ...               ...\n[30,]  0.0e+00+0.0e+00i  0.0e+00+0.0e+00i ... -6.4e-09+1.7e-07i"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "T-matrix",
    "section": "",
    "text": "Collection of scripts and self-contained examples to export/import T-matrices."
  },
  {
    "objectID": "index.html#examples-of-export-with-dummy-data",
    "href": "index.html#examples-of-export-with-dummy-data",
    "title": "T-matrix",
    "section": "Examples of export with dummy data",
    "text": "Examples of export with dummy data\n\nDoc: R • Script: test_dummy.R • Output: ar.tmat.h5\nDoc: Matlab • Script: test_dummy.m • Output: am.tmat.h5\nDoc: Julia • Script: test_dummy.jl • Output: aj.tmat.h5"
  },
  {
    "objectID": "index.html#misc.-utilities",
    "href": "index.html#misc.-utilities",
    "title": "T-matrix",
    "section": "Misc. utilities",
    "text": "Misc. utilities\n\nConversion\nDisplay\nIndexing"
  },
  {
    "objectID": "index.html#smarties-examples",
    "href": "index.html#smarties-examples",
    "title": "T-matrix",
    "section": "SMARTIES examples",
    "text": "SMARTIES examples\n\nDoc: Smarties • Script: smarties.m • Output: smarties_spectrum.tmat.h5\nBatch example: smarties_batch"
  },
  {
    "objectID": "julia_export.html",
    "href": "julia_export.html",
    "title": "Export to ‘.tmat.hdf5’ format with Julia",
    "section": "",
    "text": "This document describes the process of exporting T-matrices in the standardised HDF5 format in Julia. For illustration, we start by producing a dummy dataset. A minimal reproducible example file is available for download: test_dummy.jl."
  },
  {
    "objectID": "julia_export.html#mockup-input-data",
    "href": "julia_export.html#mockup-input-data",
    "title": "Export to ‘.tmat.hdf5’ format with Julia",
    "section": "Mockup input data",
    "text": "Mockup input data\nFor convenience, we store compound objects as named tuples, which will then be mapped into HDF5 groups during export. I did not find how to link the embedding medium from materials to the top level, so it is simply duplicated.\nusing Pkg, UUIDs\n\n# possibly multiple wavelengths\nwavelength = collect(400:50:800)\nNl = length(wavelength)\n\n# dummy 30x30 matrix values for each wavelength\ntmatrix = reshape(repeat(collect(1:900.0) + collect(1:900) * 1im, Nl),\n    (30, 30, Nl))\n\nmodes = (l=collect(1:30),\n    m=collect(1:30),\n    polarisation=repeat([\"electric\", \"magnetic\"], 15))\n\n# dummy 'analytical zeros' for e.g. EBCM methods\nazeros = collect(Iterators.product(1:2:30, 1:2:30))\nanalytical_zeros = (q=[z[1] for z in azeros[:]],\n    qp=[z[2] for z in azeros[:]])\n\nembedding = (relative_permeability=1.0,\n    relative_permittivity=1.33^2)\n\nmaterials = (embedding=embedding,\n    Au=(relative_permeability=1.0,\n        relative_permittivity=repeat([-11.4 + 1.181im], Nl)))\n        \ngeometry = (shape=\"spheroid\",\n    radiusxy=20.0,\n    radiusz=40.0)\n\n# details about computation, including full script\ncomputation = (method=\"EBCM\",\n    software=\"SMARTIES\",\n    version=\"1.1\",\n    Ntheta=40,\n    accuracy=1e-10,\n    analytical_zeros=analytical_zeros,\n    script=read(\"test_dummy.jl\", String))\n\n\npkgs = Pkg.Operations.Context().env.manifest\nhdf5version = string(pkgs[findfirst(v -&gt; v.name == \"HDF5\", pkgs)].version)\n\nall = (vacuum_wavelength=wavelength,\n    tmatrix=tmatrix,\n    modes=modes,\n    embedding=embedding,\n    materials=materials,\n    geometry=geometry,\n    computation=computation,\n    uuid=string(UUIDs.uuid4()))"
  },
  {
    "objectID": "julia_export.html#saving-to-hdf5",
    "href": "julia_export.html#saving-to-hdf5",
    "title": "Export to ‘.tmat.hdf5’ format with Julia",
    "section": "Saving to HDF5",
    "text": "Saving to HDF5\nThe HDF5.jl library provides all the tools required, and a relatively high-level interface. Unlike R and Matlab, there does not seem to be a built-in high-level way to store list-like objects (named tuples here), so I wrote the following wrapper (defined in file _fun.jl).\nfunction write_namedtuples_to_hdf5_groups(\n    parent::Union{HDF5.File,HDF5.Group},\n    tuple::NamedTuple\n)\nComplex arrays are stored with r and i fields as usual. Note that Julia has column-major ordering, unlike HDF5, and we should therefore explicitly transpose the matrix before saving it, to avoid confusion if the data are to be read in another language.\n\nusing HDF5\n\n# custom write_dicts_to_hdf5_groups()\ninclude(\"_fun.jl\")\n\nh5open(\"aj.tmat.h5\", \"w\") do fid\n\n    # write all data in groups\n    write_namedtuples_to_hdf5_groups(fid, all)\n\n    # write custom attributes\n    attributes(fid)[\"name\"] = \"Au prolate spheroid in water\"\n    attributes(fid)[\"created_with\"] = \"HDF5.jl\"\n    attributes(fid)[\"storage_format_version\"] = hdf5version\n    attributes(fid)[\"description\"] = \"Computation using SMARTIES, a numerically robust EBCM implementation for spheroids\"\n    attributes(fid)[\"keywords\"] = \"gold, spheroid, ebcm\"\n    attributes(fid[\"vacuum_wavelength\"])[\"unit\"] = \"nm\"\n    attributes(fid[\"uuid\"])[\"version\"] = \"4\"\n    attributes(fid[\"geometry\"])[\"name\"] = \"prolate spheroid\"\n\nend"
  },
  {
    "objectID": "indexing.html",
    "href": "indexing.html",
    "title": "Indexing conventions",
    "section": "",
    "text": "The convention is to use\n\nm: multipole order, -l:l\nl: multipole degree 1:lmax\ns: multipole polarisation type, 1 or 2\n\nso for a T-matrix with \\(lmax=3\\), we have\n\n\nl: 1..3\nm: -3..3\ns: 1..2\n900 elements\n\n\n\n\n\n\n\n\n\nfor each block we introduce a combined p-index such that,\n\\[\np(n,m) = n(n+1)+m\n\\] which here varies as p: 1..15, as each block is of dimension pmax = lmax(lmax+1)+lmax = 3(3+1)+3 = 15.\nThe whole T-matrix is indexed with a combined q-index such that,\n\\[\nq(s,p) = (s-1)p_{max} + p\n\\] which here gives us, q: 1..30. The total T-matrix dimension (along rows/columns) is thus \\(q_{max}=2\\times(lmax(lmax+1)+lmax)=30\\).\nIn summary, for a given \\(l_\\text{max}\\) the indices are given by:\n\n\\(l=1:l_\\text{max}\\)\n\\(m=-l:l\\) for each l\n\\(s=1:2\\) for each pair of (l,m)\n\\(p(l,m) = l(l+1)+m\\)\n\\(q(s,p) = (s-1)p_{max} + p\\)\n\nGiven \\(q\\) and \\(l_\\text{max}\\) we can invert these indices as follows,\n\n\\(p = q - (s-1)q_\\text{max}/2\\),\ngiving here, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15\n\\(l = \\lfloor\\sqrt{p}\\rfloor\\),\ngiving here 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3\n\\(m = p - l(l+1)\\),\ngiving here -1, 0, 1, -2, -1, 0, 1, 2, -3, -2, -1, 0, 1, 2, 3, -1, 0, 1, -2, -1, 0, 1, 2, -3, -2, -1, 0, 1, 2, 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n\np\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nl\n1\n1\n1\n2\n2\n2\n2\n2\n3\n3\n3\n3\n3\n3\n3\n1\n1\n1\n2\n2\n2\n2\n2\n3\n3\n3\n3\n3\n3\n3\n\n\nm\n-1\n0\n1\n-2\n-1\n0\n1\n2\n-3\n-2\n-1\n0\n1\n2\n3\n-1\n0\n1\n-2\n-1\n0\n1\n2\n-3\n-2\n-1\n0\n1\n2\n3\n\n\ns\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2"
  },
  {
    "objectID": "matlab_export.html",
    "href": "matlab_export.html",
    "title": "Export to ‘.tmat.hdf5’ format with Matlab",
    "section": "",
    "text": "This document describes a few Matlab utility functions to export T-matrices in the standardised HDF5 format. For illustration, we start by producing a dummy dataset. The SMARTIES implementation of EBCM for spheroids uses these tools internally for its HDF5 export. A minimal reproducible example file is available for download: test_dummy.m."
  },
  {
    "objectID": "matlab_export.html#mockup-input-data",
    "href": "matlab_export.html#mockup-input-data",
    "title": "Export to ‘.tmat.hdf5’ format with Matlab",
    "section": "Mockup input data",
    "text": "Mockup input data\nThe easyh5 library takes care of most of the details for us, when objects are stored in Matlab structures. There are a couple of caveats, illustrated below, such as polarization being handled separately, and attributes being added at a later stage.\n% possibly multiple wavelengths\nwavelength  = (400:50:800)';\nNl = length(wavelength);\n\n% dummy 30x30 matrix values for each wavelength\ntdata = reshape((1:900) + 1i*(1:900), [30,30]);\ntmatrix = repmat(tdata, [1,1,Nl]);\n\n% modes, but note that polarization is handled separately\nmodes = struct('l', 1:30, 'm', 1:30); \npolarization = repmat([\"electric\",\"magnetic\"], 1, 15);\n\n% dummy 'analytical zeros' for e.g. EBCM methods\n[zerosq, zerosqp] = ndgrid(1:2:30, 1:2:30);\nzeros  = struct('q', zerosq, 'qp', zerosqp);\n\n% materials\nembedding = struct('relative_permeability', 1.0, ...\n                   'relative_permittivity', 1.33^2);\nparticle = struct('relative_permeability', 1.0, ...\n                  'relative_permittivity', repmat(-11.4+1.181i, [1,Nl]));\nmaterialname = 'Au'; \nmaterials = struct('embedding', embedding, materialname, particle);\n\n% geometry\ngeometry = struct('shape', 'spheroid', 'radiusxy', 20.0, 'radiusz', 40.0);\n\n% details about computation, including full script\ncomputation = struct('method','EBCM',...\n    'software','SMARTIES',...\n    'version','1.1',...\n    'Ntheta', 40, ...\n    'accuracy','1e-10', ...\n    'analytical_zeros', zeros, ...\n    'script', fileread('test_dummy.m')); % embed full script as string\n\n% combined (almost all) information into one struct\na = struct('tmatrix', tmatrix, ...\n    'vacuum_wavelength', wavelength, ...\n    'embedding', embedding,...\n    'materials', materials, ...\n    'geometry', geometry, ...\n    'modes', modes, ...\n    'computation', computation, ...\n    'uuid', char(matlab.lang.internal.uuid()));    \n\n[maj,min,rel] = H5.get_libversion();\nhdf5version = sprintf('%d.%d.%d',maj,min,rel);"
  },
  {
    "objectID": "matlab_export.html#saving-to-hdf5",
    "href": "matlab_export.html#saving-to-hdf5",
    "title": "Export to ‘.tmat.hdf5’ format with Matlab",
    "section": "Saving to HDF5",
    "text": "Saving to HDF5\naddpath(genpath('../easyh5/'));\nsaveh5 does most of the work, but we have to write polarization separately as arrays of strings within structs seem to trip easyh5. I did not find how to link the embedding medium from materials to the top level, so it is simply duplicated.\n% save to file\nf = 'am.tmat.h5';\nsaveh5(a, f, 'ComplexFormat', {'r','i'}, 'rootname', '', ...\n       'Compression', 'deflate'); % compression is optional\n\n% write polarization separately\nh5create(f,'/modes/polarization', size(polarization), 'Datatype', 'string')\nh5write(f,'/modes/polarization', polarization)\nAttributes are written in a separate step.\n% write root attributes\nh5writeatt(f, '/', 'name', 'Au prolate spheroid in water');\nh5writeatt(f, '/', 'created_with', 'Matlab easyh5');\nh5writeatt(f, '/','keywords', 'gold, spheroid, ebcm');\nh5writeatt(f, '/', 'storage_format_version', hdf5version);\nh5writeatt(f, '/','description', ...\n    'Computation using SMARTIES, a robust EBCM for spheroids');\n    \n% attributes of specific objects\nh5writeatt(f, '/vacuum_wavelength', 'unit', 'nm');\nh5writeatt(f, '/uuid', 'version', '4');\nh5writeatt(f, '/geometry', 'name', 'prolate spheroid');"
  }
]